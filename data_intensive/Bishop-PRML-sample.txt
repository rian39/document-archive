e
l
p
m
a
S

r
e
t
p
a
h
C

Pattern Recognition and Machine Learning

Christopher M. Bishop
Copyright c 2002–2006

This is an extract from the book Pattern Recognition and Machine Learning published by Springer (2006).
It contains the preface with details about the mathematical notation, the complete table of contents of the
book and an unabridged version of chapter 8 on Graphical Models. This document, as well as further
information about the book, is available from:

http://research.microsoft.com/∼cmbishop/PRML

Preface
Pattern recognition has its origins in engineering, whereas machine learning grew
out of computer science. However, these activities can be viewed as two facets of
the same field, and together they have undergone substantial development over the
past ten years. In particular, Bayesian methods have grown from a specialist niche to
become mainstream, while graphical models have emerged as a general framework
for describing and applying probabilistic models. Also, the practical applicability of
Bayesian methods has been greatly enhanced through the development of a range of
approximate inference algorithms such as variational Bayes and expectation propagation. Similarly, new models based on kernels have had significant impact on both
algorithms and applications.
This new textbook reflects these recent developments while providing a comprehensive introduction to the fields of pattern recognition and machine learning. It is
aimed at advanced undergraduates or first year PhD students, as well as researchers
and practitioners, and assumes no previous knowledge of pattern recognition or machine learning concepts. Knowledge of multivariate calculus and basic linear algebra
is required, and some familiarity with probabilities would be helpful though not essential as the book includes a self-contained introduction to basic probability theory.
Because this book has broad scope, it is impossible to provide a complete list of
references, and in particular no attempt has been made to provide accurate historical
attribution of ideas. Instead, the aim has been to give references that offer greater
detail than is possible here and that hopefully provide entry points into what, in some
cases, is a very extensive literature. For this reason, the references are often to more
recent textbooks and review articles rather than to original sources.
The book is supported by a great deal of additional material, including lecture
slides as well as the complete set of figures used in the book, and the reader is
encouraged to visit the book web site for the latest information:

http://research.microsoft.com/∼cmbishop/PRML
vii

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

viii

PREFACE

Exercises
The exercises that appear at the end of every chapter form an important component of the book. Each exercise has been carefully chosen to reinforce concepts
explained in the text or to develop and generalize them in significant ways, and each
is graded according to difficulty ranging from ( ), which denotes a simple exercise
taking a few minutes to complete, through to (
), which denotes a significantly
more complex exercise.
It has been difficult to know to what extent worked solutions should be made
widely available. Those engaged in self study will find worked solutions very beneficial, whereas many course tutors request that solutions be available only via the
publisher so that the exercises may be used in class. In order to try to meet these
conflicting requirements, those exercises that help amplify key points in the text, or
that fill in important details, have solutions that are available as a PDF file from the
book web site. Such exercises are denoted by www . Solutions for the remaining
exercises are available to course tutors by contacting the publisher (contact details
are given on the book web site). Readers are strongly encouraged to work through
the exercises unaided, and to turn to the solutions only as required.
Although this book focuses on concepts and principles, in a taught course the
students should ideally have the opportunity to experiment with some of the key
algorithms using appropriate data sets. A companion volume (Bishop and Nabney,
2008) will deal with practical aspects of pattern recognition and machine learning,
and will be accompanied by Matlab software implementing most of the algorithms
discussed in this book.

Acknowledgements
First of all I would like to express my sincere thanks to Markus Svens´
en who
has provided immense help with preparation of figures and with the typesetting of
A
the book in L
TEX. His assistance has been invaluable.
I am very grateful to Microsoft Research for providing a highly stimulating research environment and for giving me the freedom to write this book (the views and
opinions expressed in this book, however, are my own and are therefore not necessarily the same as those of Microsoft or its affiliates).
Springer has provided excellent support throughout the final stages of preparation of this book, and I would like to thank my commissioning editor John Kimmel
for his support and professionalism, as well as Joseph Piliero for his help in designing the cover and the text format and MaryAnn Brickner for her numerous contributions during the production phase. The inspiration for the cover design came from a
discussion with Antonio Criminisi.
I also wish to thank Oxford University Press for permission to reproduce excerpts from an earlier textbook, Neural Networks for Pattern Recognition (Bishop,
1995a). The images of the Mark 1 perceptron and of Frank Rosenblatt are reproduced with the permission of Arvin Calspan Advanced Technology Center. I would
also like to thank Asela Gunawardana for plotting the spectrogram in Figure 13.1,
and Bernhard Sch¨
olkopf for permission to use his kernel PCA code to plot Figure 12.17.

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

PREFACE

ix

Many people have helped by proofreading draft material and providing comments and suggestions, including Shivani Agarwal, C´
edric Archambeau, Arik Azran,
Andrew Blake, Hakan Cevikalp, Michael Fourman, Brendan Frey, Zoubin Ghahramani, Thore Graepel, Katherine Heller, Ralf Herbrich, Geoffrey Hinton, Adam Johansen, Matthew Johnson, Michael Jordan, Eva Kalyvianaki, Anitha Kannan, Julia
Lasserre, David Liu, Tom Minka, Ian Nabney, Tonatiuh Pena, Yuan Qi, Sam Roweis,
Balaji Sanjiya, Toby Sharp, Ana Costa e Silva, David Spiegelhalter, Jay Stokes, Tara
Symeonides, Martin Szummer, Marshall Tappen, Ilkay Ulusoy, Chris Williams, John
Winn, and Andrew Zisserman.
Finally, I would like to thank my wife Jenna who has been hugely supportive
throughout the several years it has taken to write this book.
Chris Bishop
Cambridge
February 2006

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

Mathematical notation
I have tried to keep the mathematical content of the book to the minimum necessary to achieve a proper understanding of the field. However, this minimum level is
nonzero, and it should be emphasized that a good grasp of calculus, linear algebra,
and probability theory is essential for a clear understanding of modern pattern recognition and machine learning techniques. Nevertheless, the emphasis in this book is
on conveying the underlying concepts rather than on mathematical rigour.
I have tried to use a consistent notation throughout the book, although at times
this means departing from some of the conventions used in the corresponding research literature. Vectors are denoted by lower case bold Roman letters such as
x, and all vectors are assumed to be column vectors. A superscript T denotes the
transpose of a matrix or vector, so that xT will be a row vector. Uppercase bold
roman letters, such as M, denote matrices. The notation (w1 , . . . , wM ) denotes a
row vector with M elements, while the corresponding column vector is written as
w = (w1 , . . . , wM )T .
The notation [a, b] is used to denote the closed interval from a to b, that is the
interval including the values a and b themselves, while (a, b) denotes the corresponding open interval, that is the interval excluding a and b. Similarly, [a, b) denotes an
interval that includes a but excludes b. For the most part, however, there will be
little need to dwell on such refinements as whether the end points of an interval are
included or not.
The M × M identity matrix (also known as the unit matrix) is denoted IM ,
which will be abbreviated to I where there is no ambiguity about it dimensionality.
It has elements Iij that equal 1 if i = j and 0 if i = j.
A functional is denoted f [y] where y(x) is some function. The concept of a
functional is discussed in Appendix D.
The notation g(x) = O(f (x)) denotes that |f (x)/g(x)| is bounded as x → ∞.
For instance if g(x) = 3x2 + 2, then g(x) = O(x2 ).
The expectation of a function f (x, y) with respect to a random variable x is denoted by Ex [f (x, y)]. In situations where there is no ambiguity as to which variable
is being averaged over, this will be simplified by omitting the suffix, for instance
xi

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

xii

MATHEMATICAL NOTATION
E[x]. If the distribution of x is conditioned on another variable z, then the corresponding conditional expectation will be written Ex [f (x)|z]. Similarly, the variance
is denoted var[f (x)], and for vector variables the covariance is written cov[x, y]. We
shall also use cov[x] as a shorthand notation for cov[x, x]. The concepts of expectations and covariances are introduced in Section 1.2.2.
If we have N values x1 , . . . , xN of a D-dimensional vector x = (x1 , . . . , xD )T ,
we can combine the observations into a data matrix X in which the nth row of X
corresponds to the row vector xT
n . Thus the n, i element of X corresponds to the
ith element of the nth observation xn . For the case of one-dimensional variables we
shall denote such a matrix by x, which is a column vector whose nth element is xn .
Note that x (which has dimensionality N ) uses a different typeface to distinguish it
from x (which has dimensionality D).

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

Contents
Preface

vii

Mathematical notation

xi

Contents
1

Introduction
1.1 Example: Polynomial Curve Fitting . . . . . . .
1.2 Probability Theory . . . . . . . . . . . . . . . .
1.2.1 Probability densities . . . . . . . . . . .
1.2.2 Expectations and covariances . . . . . .
1.2.3 Bayesian probabilities . . . . . . . . . .
1.2.4 The Gaussian distribution . . . . . . . .
1.2.5 Curve fitting re-visited . . . . . . . . . .
1.2.6 Bayesian curve fitting . . . . . . . . . .
1.3 Model Selection . . . . . . . . . . . . . . . . .
1.4 The Curse of Dimensionality . . . . . . . . . . .
1.5 Decision Theory . . . . . . . . . . . . . . . . .
1.5.1 Minimizing the misclassification rate . .
1.5.2 Minimizing the expected loss . . . . . .
1.5.3 The reject option . . . . . . . . . . . . .
1.5.4 Inference and decision . . . . . . . . . .
1.5.5 Loss functions for regression . . . . . . .
1.6 Information Theory . . . . . . . . . . . . . . . .
1.6.1 Relative entropy and mutual information
Exercises . . . . . . . . . . . . . . . . . . . . . . . .

xiii

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

1
4
12
17
19
21
24
28
30
32
33
38
39
41
42
42
46
48
55
58
xiii

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

xiv

CONTENTS
2

3

Probability Distributions
2.1 Binary Variables . . . . . . . . . . . . . . . . . . .
2.1.1 The beta distribution . . . . . . . . . . . . .
2.2 Multinomial Variables . . . . . . . . . . . . . . . .
2.2.1 The Dirichlet distribution . . . . . . . . . . .
2.3 The Gaussian Distribution . . . . . . . . . . . . . .
2.3.1 Conditional Gaussian distributions . . . . . .
2.3.2 Marginal Gaussian distributions . . . . . . .
2.3.3 Bayes’ theorem for Gaussian variables . . . .
2.3.4 Maximum likelihood for the Gaussian . . . .
2.3.5 Sequential estimation . . . . . . . . . . . . .
2.3.6 Bayesian inference for the Gaussian . . . . .
2.3.7 Student’s t-distribution . . . . . . . . . . . .
2.3.8 Periodic variables . . . . . . . . . . . . . . .
2.3.9 Mixtures of Gaussians . . . . . . . . . . . .
2.4 The Exponential Family . . . . . . . . . . . . . . .
2.4.1 Maximum likelihood and sufficient statistics
2.4.2 Conjugate priors . . . . . . . . . . . . . . .
2.4.3 Noninformative priors . . . . . . . . . . . .
2.5 Nonparametric Methods . . . . . . . . . . . . . . .
2.5.1 Kernel density estimators . . . . . . . . . . .
2.5.2 Nearest-neighbour methods . . . . . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

67
68
71
74
76
78
85
88
90
93
94
97
102
105
110
113
116
117
117
120
122
124
127

Linear Models for Regression
3.1 Linear Basis Function Models . . . . . . . . .
3.1.1 Maximum likelihood and least squares .
3.1.2 Geometry of least squares . . . . . . .
3.1.3 Sequential learning . . . . . . . . . . .
3.1.4 Regularized least squares . . . . . . . .
3.1.5 Multiple outputs . . . . . . . . . . . .
3.2 The Bias-Variance Decomposition . . . . . . .
3.3 Bayesian Linear Regression . . . . . . . . . .
3.3.1 Parameter distribution . . . . . . . . .
3.3.2 Predictive distribution . . . . . . . . .
3.3.3 Equivalent kernel . . . . . . . . . . . .
3.4 Bayesian Model Comparison . . . . . . . . . .
3.5 The Evidence Approximation . . . . . . . . .
3.5.1 Evaluation of the evidence function . .
3.5.2 Maximizing the evidence function . . .
3.5.3 Effective number of parameters . . . .
3.6 Limitations of Fixed Basis Functions . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

137
138
140
143
143
144
146
147
152
153
156
157
161
165
166
168
170
172
173

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

xv

CONTENTS
4

5

Linear Models for Classification
4.1 Discriminant Functions . . . . . . . . . . . . . .
4.1.1 Two classes . . . . . . . . . . . . . . . .
4.1.2 Multiple classes . . . . . . . . . . . . . .
4.1.3 Least squares for classification . . . . . .
4.1.4 Fisher’s linear discriminant . . . . . . . .
4.1.5 Relation to least squares . . . . . . . . .
4.1.6 Fisher’s discriminant for multiple classes
4.1.7 The perceptron algorithm . . . . . . . . .
4.2 Probabilistic Generative Models . . . . . . . . .
4.2.1 Continuous inputs . . . . . . . . . . . .
4.2.2 Maximum likelihood solution . . . . . .
4.2.3 Discrete features . . . . . . . . . . . . .
4.2.4 Exponential family . . . . . . . . . . . .
4.3 Probabilistic Discriminative Models . . . . . . .
4.3.1 Fixed basis functions . . . . . . . . . . .
4.3.2 Logistic regression . . . . . . . . . . . .
4.3.3 Iterative reweighted least squares . . . .
4.3.4 Multiclass logistic regression . . . . . . .
4.3.5 Probit regression . . . . . . . . . . . . .
4.3.6 Canonical link functions . . . . . . . . .
4.4 The Laplace Approximation . . . . . . . . . . .
4.4.1 Model comparison and BIC . . . . . . .
4.5 Bayesian Logistic Regression . . . . . . . . . .
4.5.1 Laplace approximation . . . . . . . . . .
4.5.2 Predictive distribution . . . . . . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

179
181
181
182
184
186
189
191
192
196
198
200
202
202
203
204
205
207
209
210
212
213
216
217
217
218
220

Neural Networks
5.1 Feed-forward Network Functions . . . . . . .
5.1.1 Weight-space symmetries . . . . . . .
5.2 Network Training . . . . . . . . . . . . . . . .
5.2.1 Parameter optimization . . . . . . . . .
5.2.2 Local quadratic approximation . . . . .
5.2.3 Use of gradient information . . . . . .
5.2.4 Gradient descent optimization . . . . .
5.3 Error Backpropagation . . . . . . . . . . . . .
5.3.1 Evaluation of error-function derivatives
5.3.2 A simple example . . . . . . . . . . .
5.3.3 Efficiency of backpropagation . . . . .
5.3.4 The Jacobian matrix . . . . . . . . . .
5.4 The Hessian Matrix . . . . . . . . . . . . . . .
5.4.1 Diagonal approximation . . . . . . . .
5.4.2 Outer product approximation . . . . . .
5.4.3 Inverse Hessian . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

225
227
231
232
236
237
239
240
241
242
245
246
247
249
250
251
252

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

xvi

CONTENTS
5.4.4 Finite differences . . . . . . . . . . . . . .
5.4.5 Exact evaluation of the Hessian . . . . . .
5.4.6 Fast multiplication by the Hessian . . . . .
5.5 Regularization in Neural Networks . . . . . . . .
5.5.1 Consistent Gaussian priors . . . . . . . . .
5.5.2 Early stopping . . . . . . . . . . . . . . .
5.5.3 Invariances . . . . . . . . . . . . . . . . .
5.5.4 Tangent propagation . . . . . . . . . . . .
5.5.5 Training with transformed data . . . . . . .
5.5.6 Convolutional networks . . . . . . . . . .
5.5.7 Soft weight sharing . . . . . . . . . . . . .
5.6 Mixture Density Networks . . . . . . . . . . . . .
5.7 Bayesian Neural Networks . . . . . . . . . . . . .
5.7.1 Posterior parameter distribution . . . . . .
5.7.2 Hyperparameter optimization . . . . . . .
5.7.3 Bayesian neural networks for classification
Exercises . . . . . . . . . . . . . . . . . . . . . . . . .
6

7

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

252
253
254
256
257
259
261
263
265
267
269
272
277
278
280
281
284

Kernel Methods
6.1 Dual Representations . . . . . . . . . . . .
6.2 Constructing Kernels . . . . . . . . . . . .
6.3 Radial Basis Function Networks . . . . . .
6.3.1 Nadaraya-Watson model . . . . . .
6.4 Gaussian Processes . . . . . . . . . . . . .
6.4.1 Linear regression revisited . . . . .
6.4.2 Gaussian processes for regression .
6.4.3 Learning the hyperparameters . . .
6.4.4 Automatic relevance determination
6.4.5 Gaussian processes for classification
6.4.6 Laplace approximation . . . . . . .
6.4.7 Connection to neural networks . . .
Exercises . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

291
293
294
299
301
303
304
306
311
312
313
315
319
320

Sparse Kernel Machines
7.1 Maximum Margin Classifiers . . . .
7.1.1 Overlapping class distributions
7.1.2 Relation to logistic regression
7.1.3 Multiclass SVMs . . . . . . .
7.1.4 SVMs for regression . . . . .
7.1.5 Computational learning theory
7.2 Relevance Vector Machines . . . . .
7.2.1 RVM for regression . . . . . .
7.2.2 Analysis of sparsity . . . . . .
7.2.3 RVM for classification . . . .
Exercises . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

325
326
331
336
338
339
344
345
345
349
353
357

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

xvii

CONTENTS
8

Graphical Models
8.1 Bayesian Networks . . . . . . . . . . . . . .
8.1.1 Example: Polynomial regression . . .
8.1.2 Generative models . . . . . . . . . .
8.1.3 Discrete variables . . . . . . . . . . .
8.1.4 Linear-Gaussian models . . . . . . .
8.2 Conditional Independence . . . . . . . . . .
8.2.1 Three example graphs . . . . . . . .
8.2.2 D-separation . . . . . . . . . . . . .
8.3 Markov Random Fields . . . . . . . . . . .
8.3.1 Conditional independence properties .
8.3.2 Factorization properties . . . . . . .
8.3.3 Illustration: Image de-noising . . . .
8.3.4 Relation to directed graphs . . . . . .
8.4 Inference in Graphical Models . . . . . . . .
8.4.1 Inference on a chain . . . . . . . . .
8.4.2 Trees . . . . . . . . . . . . . . . . .
8.4.3 Factor graphs . . . . . . . . . . . . .
8.4.4 The sum-product algorithm . . . . . .
8.4.5 The max-sum algorithm . . . . . . .
8.4.6 Exact inference in general graphs . .
8.4.7 Loopy belief propagation . . . . . . .
8.4.8 Learning the graph structure . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

359
360
362
365
366
370
372
373
378
383
383
384
387
390
393
394
398
399
402
411
416
417
418
418

Mixture Models and EM
9.1 K-means Clustering . . . . . . . . . . . . .
9.1.1 Image segmentation and compression
9.2 Mixtures of Gaussians . . . . . . . . . . . .
9.2.1 Maximum likelihood . . . . . . . . .
9.2.2 EM for Gaussian mixtures . . . . . .
9.3 An Alternative View of EM . . . . . . . . .
9.3.1 Gaussian mixtures revisited . . . . .
9.3.2 Relation to K-means . . . . . . . . .
9.3.3 Mixtures of Bernoulli distributions . .
9.3.4 EM for Bayesian linear regression . .
9.4 The EM Algorithm in General . . . . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

423
424
428
430
432
435
439
441
443
444
448
450
455

10 Approximate Inference
10.1 Variational Inference . . . . . . . . . . . . . .
10.1.1 Factorized distributions . . . . . . . . .
10.1.2 Properties of factorized approximations
10.1.3 Example: The univariate Gaussian . . .
10.1.4 Model comparison . . . . . . . . . . .
10.2 Illustration: Variational Mixture of Gaussians .

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

461
462
464
466
470
473
474

9

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

xviii

CONTENTS
10.2.1 Variational distribution . . . . . . . . .
10.2.2 Variational lower bound . . . . . . . .
10.2.3 Predictive density . . . . . . . . . . . .
10.2.4 Determining the number of components
10.2.5 Induced factorizations . . . . . . . . .
10.3 Variational Linear Regression . . . . . . . . .
10.3.1 Variational distribution . . . . . . . . .
10.3.2 Predictive distribution . . . . . . . . .
10.3.3 Lower bound . . . . . . . . . . . . . .
10.4 Exponential Family Distributions . . . . . . .
10.4.1 Variational message passing . . . . . .
10.5 Local Variational Methods . . . . . . . . . . .
10.6 Variational Logistic Regression . . . . . . . .
10.6.1 Variational posterior distribution . . . .
10.6.2 Optimizing the variational parameters .
10.6.3 Inference of hyperparameters . . . . .
10.7 Expectation Propagation . . . . . . . . . . . .
10.7.1 Example: The clutter problem . . . . .
10.7.2 Expectation propagation on graphs . . .
Exercises . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

475
481
482
483
485
486
486
488
489
490
491
493
498
498
500
502
505
511
513
517

11 Sampling Methods
11.1 Basic Sampling Algorithms . . . . . . . .
11.1.1 Standard distributions . . . . . . .
11.1.2 Rejection sampling . . . . . . . . .
11.1.3 Adaptive rejection sampling . . . .
11.1.4 Importance sampling . . . . . . . .
11.1.5 Sampling-importance-resampling .
11.1.6 Sampling and the EM algorithm . .
11.2 Markov Chain Monte Carlo . . . . . . . .
11.2.1 Markov chains . . . . . . . . . . .
11.2.2 The Metropolis-Hastings algorithm
11.3 Gibbs Sampling . . . . . . . . . . . . . .
11.4 Slice Sampling . . . . . . . . . . . . . . .
11.5 The Hybrid Monte Carlo Algorithm . . . .
11.5.1 Dynamical systems . . . . . . . . .
11.5.2 Hybrid Monte Carlo . . . . . . . .
11.6 Estimating the Partition Function . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

523
526
526
528
530
532
534
536
537
539
541
542
546
548
548
552
554
556

12 Continuous Latent Variables
12.1 Principal Component Analysis . . . . .
12.1.1 Maximum variance formulation
12.1.2 Minimum-error formulation . .
12.1.3 Applications of PCA . . . . . .
12.1.4 PCA for high-dimensional data

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

559
561
561
563
565
569

.
.
.
.
.

.
.
.
.
.

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

xix

CONTENTS
12.2 Probabilistic PCA . . . . . . . . . . .
12.2.1 Maximum likelihood PCA . . .
12.2.2 EM algorithm for PCA . . . . .
12.2.3 Bayesian PCA . . . . . . . . .
12.2.4 Factor analysis . . . . . . . . .
12.3 Kernel PCA . . . . . . . . . . . . . . .
12.4 Nonlinear Latent Variable Models . . .
12.4.1 Independent component analysis
12.4.2 Autoassociative neural networks
12.4.3 Modelling nonlinear manifolds .
Exercises . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

570
574
577
580
583
586
591
591
592
595
599

13 Sequential Data
13.1 Markov Models . . . . . . . . . . . . . . . . . .
13.2 Hidden Markov Models . . . . . . . . . . . . .
13.2.1 Maximum likelihood for the HMM . . .
13.2.2 The forward-backward algorithm . . . .
13.2.3 The sum-product algorithm for the HMM
13.2.4 Scaling factors . . . . . . . . . . . . . .
13.2.5 The Viterbi algorithm . . . . . . . . . . .
13.2.6 Extensions of the hidden Markov model .
13.3 Linear Dynamical Systems . . . . . . . . . . . .
13.3.1 Inference in LDS . . . . . . . . . . . . .
13.3.2 Learning in LDS . . . . . . . . . . . . .
13.3.3 Extensions of LDS . . . . . . . . . . . .
13.3.4 Particle filters . . . . . . . . . . . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

605
607
610
615
618
625
627
629
631
635
638
642
644
645
646

14 Combining Models
14.1 Bayesian Model Averaging . . . . . . . . . .
14.2 Committees . . . . . . . . . . . . . . . . . .
14.3 Boosting . . . . . . . . . . . . . . . . . . .
14.3.1 Minimizing exponential error . . . .
14.3.2 Error functions for boosting . . . . .
14.4 Tree-based Models . . . . . . . . . . . . . .
14.5 Conditional Mixture Models . . . . . . . . .
14.5.1 Mixtures of linear regression models .
14.5.2 Mixtures of logistic models . . . . .
14.5.3 Mixtures of experts . . . . . . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

653
654
655
657
659
661
663
666
667
670
672
674

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

Appendix A

Data Sets

677

Appendix B

Probability Distributions

685

Appendix C

Properties of Matrices

695

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

xx

CONTENTS
Appendix D

Calculus of Variations

703

Appendix E

Lagrange Multipliers

707

References

711

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8
Graphical
Models

Probabilities play a central role in modern pattern recognition. We have seen in
Chapter 1 that probability theory can be expressed in terms of two simple equations
corresponding to the sum rule and the product rule. All of the probabilistic inference and learning manipulations discussed in this book, no matter how complex,
amount to repeated application of these two equations. We could therefore proceed
to formulate and solve complicated probabilistic models purely by algebraic manipulation. However, we shall find it highly advantageous to augment the analysis
using diagrammatic representations of probability distributions, called probabilistic
graphical models. These offer several useful properties:
1. They provide a simple way to visualize the structure of a probabilistic model
and can be used to design and motivate new models.
2. Insights into the properties of the model, including conditional independence
properties, can be obtained by inspection of the graph.
359

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

360

8. GRAPHICAL MODELS
3. Complex computations, required to perform inference and learning in sophisticated models, can be expressed in terms of graphical manipulations, in which
underlying mathematical expressions are carried along implicitly.
A graph comprises nodes (also called vertices) connected by links (also known
as edges or arcs). In a probabilistic graphical model, each node represents a random
variable (or group of random variables), and the links express probabilistic relationships between these variables. The graph then captures the way in which the joint
distribution over all of the random variables can be decomposed into a product of
factors each depending only on a subset of the variables. We shall begin by discussing Bayesian networks, also known as directed graphical models, in which the
links of the graphs have a particular directionality indicated by arrows. The other
major class of graphical models are Markov random fields, also known as undirected
graphical models, in which the links do not carry arrows and have no directional
significance. Directed graphs are useful for expressing causal relationships between
random variables, whereas undirected graphs are better suited to expressing soft constraints between random variables. For the purposes of solving inference problems,
it is often convenient to convert both directed and undirected graphs into a different
representation called a factor graph.
In this chapter, we shall focus on the key aspects of graphical models as needed
for applications in pattern recognition and machine learning. More general treatments of graphical models can be found in the books by Whittaker (1990), Lauritzen
(1996), Jensen (1996), Castillo et al. (1997), Jordan (1999), Cowell et al. (1999),
and Jordan (2007).

8.1. Bayesian Networks
In order to motivate the use of directed graphs to describe probability distributions,
consider first an arbitrary joint distribution p(a, b, c) over three variables a, b, and c.
Note that at this stage, we do not need to specify anything further about these variables, such as whether they are discrete or continuous. Indeed, one of the powerful
aspects of graphical models is that a specific graph can make probabilistic statements
for a broad class of distributions. By application of the product rule of probability
(1.11), we can write the joint distribution in the form
p(a, b, c) = p(c|a, b)p(a, b).

(8.1)

A second application of the product rule, this time to the second term on the righthand side of (8.1), gives
p(a, b, c) = p(c|a, b)p(b|a)p(a).

(8.2)

Note that this decomposition holds for any choice of the joint distribution. We now
represent the right-hand side of (8.2) in terms of a simple graphical model as follows.
First we introduce a node for each of the random variables a, b, and c and associate
each node with the corresponding conditional distribution on the right-hand side of

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

361

8.1. Bayesian Networks
Figure 8.1 A directed graphical model representing the joint probability distribution over three variables a, b, and c, corresponding to the decomposition on the right-hand side of (8.2).

a
b

c

(8.2). Then, for each conditional distribution we add directed links (arrows) to the
graph from the nodes corresponding to the variables on which the distribution is
conditioned. Thus for the factor p(c|a, b), there will be links from nodes a and b to
node c, whereas for the factor p(a) there will be no incoming links. The result is
the graph shown in Figure 8.1. If there is a link going from a node a to a node b,
then we say that node a is the parent of node b, and we say that node b is the child
of node a. Note that we shall not make any formal distinction between a node and
the variable to which it corresponds but will simply use the same symbol to refer to
both.
An interesting point to note about (8.2) is that the left-hand side is symmetrical
with respect to the three variables a, b, and c, whereas the right-hand side is not.
Indeed, in making the decomposition in (8.2), we have implicitly chosen a particular
ordering, namely a, b, c, and had we chosen a different ordering we would have
obtained a different decomposition and hence a different graphical representation.
We shall return to this point later.
For the moment let us extend the example of Figure 8.1 by considering the joint
distribution over K variables given by p(x1 , . . . , xK ). By repeated application of
the product rule of probability, this joint distribution can be written as a product of
conditional distributions, one for each of the variables
p(x1 , . . . , xK ) = p(xK |x1 , . . . , xK−1 ) . . . p(x2 |x1 )p(x1 ).

(8.3)

For a given choice of K, we can again represent this as a directed graph having K
nodes, one for each conditional distribution on the right-hand side of (8.3), with each
node having incoming links from all lower numbered nodes. We say that this graph
is fully connected because there is a link between every pair of nodes.
So far, we have worked with completely general joint distributions, so that the
decompositions, and their representations as fully connected graphs, will be applicable to any choice of distribution. As we shall see shortly, it is the absence of links
in the graph that conveys interesting information about the properties of the class of
distributions that the graph represents. Consider the graph shown in Figure 8.2.
This is not a fully connected graph because, for instance, there is no link from x1 to
x2 or from x3 to x7 .
We shall now go from this graph to the corresponding representation of the joint
probability distribution written in terms of the product of a set of conditional distributions, one for each node in the graph. Each such conditional distribution will
be conditioned only on the parents of the corresponding node in the graph. For instance, x5 will be conditioned on x1 and x3 . The joint distribution of all 7 variables

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

362

8. GRAPHICAL MODELS
Figure 8.2 Example of a directed acyclic graph describing the joint
distribution over variables x1 , . . . , x7 . The corresponding
decomposition of the joint distribution is given by (8.4).

x1
x2

x3

x4

x5

x6

x7

is therefore given by
p(x1 )p(x2 )p(x3 )p(x4 |x1 , x2 , x3 )p(x5 |x1 , x3 )p(x6 |x4 )p(x7 |x4 , x5 ).

(8.4)

The reader should take a moment to study carefully the correspondence between
(8.4) and Figure 8.2.
We can now state in general terms the relationship between a given directed
graph and the corresponding distribution over the variables. The joint distribution
defined by a graph is given by the product, over all of the nodes of the graph, of
a conditional distribution for each node conditioned on the variables corresponding
to the parents of that node in the graph. Thus, for a graph with K nodes, the joint
distribution is given by
K

p(x) =
k=1

Exercise 8.1

Exercise 8.2

p(xk |pak )

(8.5)

where pak denotes the set of parents of xk , and x = {x1 , . . . , xK }. This key
equation expresses the factorization properties of the joint distribution for a directed
graphical model. Although we have considered each node to correspond to a single
variable, we can equally well associate sets of variables and vector-valued variables
with the nodes of a graph. It is easy to show that the representation on the righthand side of (8.5) is always correctly normalized provided the individual conditional
distributions are normalized.
The directed graphs that we are considering are subject to an important restriction namely that there must be no directed cycles, in other words there are no closed
paths within the graph such that we can move from node to node along links following the direction of the arrows and end up back at the starting node. Such graphs are
also called directed acyclic graphs, or DAGs. This is equivalent to the statement that
there exists an ordering of the nodes such that there are no links that go from any
node to any lower numbered node.

8.1.1 Example: Polynomial regression
As an illustration of the use of directed graphs to describe probability distributions, we consider the Bayesian polynomial regression model introduced in Sec-

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.1. Bayesian Networks

363

w

Figure 8.3 Directed graphical model representing the joint
distribution (8.6) corresponding to the Bayesian
polynomial regression model introduced in Section 1.2.6.

t1

tN

tion 1.2.6. The random variables in this model are the vector of polynomial coefficients w and the observed data t = (t1 , . . . , tN )T . In addition, this model contains
the input data x = (x1 , . . . , xN )T , the noise variance σ 2 , and the hyperparameter α
representing the precision of the Gaussian prior over w, all of which are parameters
of the model rather than random variables. Focussing just on the random variables
for the moment, we see that the joint distribution is given by the product of the prior
p(w) and N conditional distributions p(tn |w) for n = 1, . . . , N so that
N

p(t, w) = p(w)
n=1

p(tn |w).

(8.6)

This joint distribution can be represented by a graphical model shown in Figure 8.3.
When we start to deal with more complex models later in the book, we shall find
it inconvenient to have to write out multiple nodes of the form t1 , . . . , tN explicitly as
in Figure 8.3. We therefore introduce a graphical notation that allows such multiple
nodes to be expressed more compactly, in which we draw a single representative
node tn and then surround this with a box, called a plate, labelled with N indicating
that there are N nodes of this kind. Re-writing the graph of Figure 8.3 in this way,
we obtain the graph shown in Figure 8.4.
We shall sometimes find it helpful to make the parameters of a model, as well as
its stochastic variables, explicit. In this case, (8.6) becomes
N

p(t, w|x, α, σ 2 ) = p(w|α)
n=1

p(tn |w, xn , σ 2 ).

Correspondingly, we can make x and α explicit in the graphical representation. To
do this, we shall adopt the convention that random variables will be denoted by open
circles, and deterministic parameters will be denoted by smaller solid circles. If we
take the graph of Figure 8.4 and include the deterministic parameters, we obtain the
graph shown in Figure 8.5.
When we apply a graphical model to a problem in machine learning or pattern
recognition, we will typically set some of the random variables to specific observed
Figure 8.4 An alternative, more compact, representation of the graph
shown in Figure 8.3 in which we have introduced a plate
(the box labelled N ) that represents N nodes of which only
a single example tn is shown explicitly.

w
tn

N

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

364

8. GRAPHICAL MODELS
Figure 8.5 This shows the same model as in Figure 8.4 but
with the deterministic parameters shown explicitly
by the smaller solid nodes.

xn

α

w
σ2

tn

N

values, for example the variables {tn } from the training set in the case of polynomial
curve fitting. In a graphical model, we will denote such observed variables by shading the corresponding nodes. Thus the graph corresponding to Figure 8.5 in which
the variables {tn } are observed is shown in Figure 8.6. Note that the value of w
is not observed, and so w is an example of a latent variable, also known as a hidden
variable. Such variables play a crucial role in many probabilistic models and will
form the focus of Chapters 9 and 12.
Having observed the values {tn } we can, if desired, evaluate the posterior distribution of the polynomial coefficients w as discussed in Section 1.2.5. For the
moment, we note that this involves a straightforward application of Bayes’ theorem
N

p(w|T) ∝ p(w)

n=1

p(tn |w)

(8.7)

where again we have omitted the deterministic parameters in order to keep the notation uncluttered.
In general, model parameters such as w are of little direct interest in themselves,
because our ultimate goal is to make predictions for new input values. Suppose we
are given a new input value x and we wish to find the corresponding probability distribution for t conditioned on the observed data. The graphical model that describes
this problem is shown in Figure 8.7, and the corresponding joint distribution of all
of the random variables in this model, conditioned on the deterministic parameters,
is then given by
N
2

p(t, t, w|x, x, α, σ ) =
n=1

p(tn |xn , w, σ 2 ) p(w|α)p(t|x, w, σ 2 ).

Figure 8.6 As in Figure 8.5 but with the nodes {tn } shaded
to indicate that the corresponding random variables have been set to their observed (training set)
values.

xn

(8.8)

α

w
σ2

tn

N

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.1. Bayesian Networks
Figure 8.7 The polynomial regression model, corresponding
to Figure 8.6, showing also a new input value b
x
together with the corresponding model prediction
b
t.

xn

365

α

w
tn

N

σ2

x
ˆ
ˆ
t

The required predictive distribution for t is then obtained, from the sum rule of
probability, by integrating out the model parameters w so that
p(t|x, x, t, α, σ 2 ) ∝

p(t, t, w|x, x, α, σ 2 ) dw

where we are implicitly setting the random variables in t to the specific values observed in the data set. The details of this calculation were discussed in Chapter 3.

8.1.2 Generative models
There are many situations in which we wish to draw samples from a given probability distribution. Although we shall devote the whole of Chapter 11 to a detailed
discussion of sampling methods, it is instructive to outline here one technique, called
ancestral sampling, which is particularly relevant to graphical models. Consider a
joint distribution p(x1 , . . . , xK ) over K variables that factorizes according to (8.5)
corresponding to a directed acyclic graph. We shall suppose that the variables have
been ordered such that there are no links from any node to any lower numbered node,
in other words each node has a higher number than any of its parents. Our goal is to
draw a sample x1 , . . . , xK from the joint distribution.
To do this, we start with the lowest-numbered node and draw a sample from the
distribution p(x1 ), which we call x1 . We then work through each of the nodes in order, so that for node n we draw a sample from the conditional distribution p(xn |pan )
in which the parent variables have been set to their sampled values. Note that at each
stage, these parent values will always be available because they correspond to lowernumbered nodes that have already been sampled. Techniques for sampling from
specific distributions will be discussed in detail in Chapter 11. Once we have sampled from the final variable xK , we will have achieved our objective of obtaining a
sample from the joint distribution. To obtain a sample from some marginal distribution corresponding to a subset of the variables, we simply take the sampled values
for the required nodes and ignore the sampled values for the remaining nodes. For
example, to draw a sample from the distribution p(x2 , x4 ), we simply sample from
the full joint distribution and then retain the values x2 , x4 and discard the remaining
values {xj =2,4 }.

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

366

8. GRAPHICAL MODELS
Figure 8.8 A graphical model representing the process by which Object
images of objects are created, in which the identity
of an object (a discrete variable) and the position and
orientation of that object (continuous variables) have
independent prior probabilities. The image (a vector
of pixel intensities) has a probability distribution that
is dependent on the identity of the object as well as
on its position and orientation.

Position Orientation

Image

For practical applications of probabilistic models, it will typically be the highernumbered variables corresponding to terminal nodes of the graph that represent the
observations, with lower-numbered nodes corresponding to latent variables. The
primary role of the latent variables is to allow a complicated distribution over the
observed variables to be represented in terms of a model constructed from simpler
(typically exponential family) conditional distributions.
We can interpret such models as expressing the processes by which the observed
data arose. For instance, consider an object recognition task in which each observed
data point corresponds to an image (comprising a vector of pixel intensities) of one
of the objects. In this case, the latent variables might have an interpretation as the
position and orientation of the object. Given a particular observed image, our goal is
to find the posterior distribution over objects, in which we integrate over all possible
positions and orientations. We can represent this problem using a graphical model
of the form show in Figure 8.8.
The graphical model captures the causal process (Pearl, 1988) by which the observed data was generated. For this reason, such models are often called generative
models. By contrast, the polynomial regression model described by Figure 8.5 is
not generative because there is no probability distribution associated with the input
variable x, and so it is not possible to generate synthetic data points from this model.
We could make it generative by introducing a suitable prior distribution p(x), at the
expense of a more complex model.
The hidden variables in a probabilistic model need not, however, have any explicit physical interpretation but may be introduced simply to allow a more complex
joint distribution to be constructed from simpler components. In either case, the
technique of ancestral sampling applied to a generative model mimics the creation
of the observed data and would therefore give rise to ‘fantasy’ data whose probability
distribution (if the model were a perfect representation of reality) would be the same
as that of the observed data. In practice, producing synthetic observations from a
generative model can prove informative in understanding the form of the probability
distribution represented by that model.

8.1.3 Discrete variables
Section 2.4

We have discussed the importance of probability distributions that are members
of the exponential family, and we have seen that this family includes many wellknown distributions as particular cases. Although such distributions are relatively
simple, they form useful building blocks for constructing more complex probability

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

367

8.1. Bayesian Networks
x1
Figure 8.9 (a) This fully-connected graph describes a general distribution over two K-state discrete variables having a total of (a)
K 2 − 1 parameters. (b) By dropping the link between the
nodes, the number of parameters is reduced to 2(K − 1).
x1
(b)

x2
x2

distributions, and the framework of graphical models is very useful in expressing the
way in which these building blocks are linked together.
Such models have particularly nice properties if we choose the relationship between each parent-child pair in a directed graph to be conjugate, and we shall explore several examples of this shortly. Two cases are particularly worthy of note,
namely when the parent and child node each correspond to discrete variables and
when they each correspond to Gaussian variables, because in these two cases the
relationship can be extended hierarchically to construct arbitrarily complex directed
acyclic graphs. We begin by examining the discrete case.
The probability distribution p(x|µ) for a single discrete variable x having K
possible states (using the 1-of-K representation) is given by
K
k
µx
k

p(x|µ) =

(8.9)

k=1

and is governed by the parameters µ = (µ1 , . . . , µK )T . Due to the constraint
k µk = 1, only K − 1 values for µk need to be specified in order to define the
distribution.
Now suppose that we have two discrete variables, x1 and x2 , each of which has
K states, and we wish to model their joint distribution. We denote the probability of
observing both x1k = 1 and x2l = 1 by the parameter µkl , where x1k denotes the
kth component of x1 , and similarly for x2l . The joint distribution can be written
K

p(x1 , x2 |µ) =

K
x1k x2l
µkl
.

k=1 l=1

Because the parameters µkl are subject to the constraint k l µkl = 1, this distribution is governed by K 2 − 1 parameters. It is easily seen that the total number of
parameters that must be specified for an arbitrary joint distribution over M variables
is K M − 1 and therefore grows exponentially with the number M of variables.
Using the product rule, we can factor the joint distribution p(x1 , x2 ) in the form
p(x2 |x1 )p(x1 ), which corresponds to a two-node graph with a link going from the
x1 node to the x2 node as shown in Figure 8.9(a). The marginal distribution p(x1 )
is governed by K − 1 parameters, as before, Similarly, the conditional distribution
p(x2 |x1 ) requires the specification of K − 1 parameters for each of the K possible
values of x1 . The total number of parameters that must be specified in the joint
distribution is therefore (K − 1) + K(K − 1) = K 2 − 1 as before.
Now suppose that the variables x1 and x2 were independent, corresponding to
the graphical model shown in Figure 8.9(b). Each variable is then described by

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

368

8. GRAPHICAL MODELS

Figure 8.10 This chain of M discrete nodes, each x1
having K states, requires the specification of K − 1 +
(M − 1)K(K − 1) parameters, which grows linearly
with the length M of the chain. In contrast, a fully connected graph of M nodes would have K M − 1 parameters, which grows exponentially with M .

x2

xM

a separate multinomial distribution, and the total number of parameters would be
2(K − 1). For a distribution over M independent discrete variables, each having K
states, the total number of parameters would be M (K − 1), which therefore grows
linearly with the number of variables. From a graphical perspective, we have reduced
the number of parameters by dropping links in the graph, at the expense of having a
restricted class of distributions.
More generally, if we have M discrete variables x1 , . . . , xM , we can model
the joint distribution using a directed graph with one variable corresponding to each
node. The conditional distribution at each node is given by a set of nonnegative parameters subject to the usual normalization constraint. If the graph is fully connected
then we have a completely general distribution having K M − 1 parameters, whereas
if there are no links in the graph the joint distribution factorizes into the product of
the marginals, and the total number of parameters is M (K − 1). Graphs having intermediate levels of connectivity allow for more general distributions than the fully
factorized one while requiring fewer parameters than the general joint distribution.
As an illustration, consider the chain of nodes shown in Figure 8.10. The marginal
distribution p(x1 ) requires K − 1 parameters, whereas each of the M − 1 conditional distributions p(xi |xi−1 ), for i = 2, . . . , M , requires K(K − 1) parameters.
This gives a total parameter count of K − 1 + (M − 1)K(K − 1), which is quadratic
in K and which grows linearly (rather than exponentially) with the length M of the
chain.
An alternative way to reduce the number of independent parameters in a model
is by sharing parameters (also known as tying of parameters). For instance, in the
chain example of Figure 8.10, we can arrange that all of the conditional distributions
p(xi |xi−1 ), for i = 2, . . . , M , are governed by the same set of K(K −1) parameters.
Together with the K −1 parameters governing the distribution of x1 , this gives a total
of K 2 − 1 parameters that must be specified in order to define the joint distribution.
We can turn a graph over discrete variables into a Bayesian model by introducing Dirichlet priors for the parameters. From a graphical point of view, each node
then acquires an additional parent representing the Dirichlet distribution over the parameters associated with the corresponding discrete node. This is illustrated for the
chain model in Figure 8.11. The corresponding model in which we tie the parameters governing the conditional distributions p(xi |xi−1 ), for i = 2, . . . , M , is shown
in Figure 8.12.
Another way of controlling the exponential growth in the number of parameters
in models of discrete variables is to use parameterized models for the conditional
distributions instead of complete tables of conditional probability values. To illustrate this idea, consider the graph in Figure 8.13 in which all of the nodes represent
binary variables. Each of the parent variables xi is governed by a single parame-

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.1. Bayesian Networks

369

Figure 8.11 An extension of the model of µ1
Figure 8.10 to include Dirichlet priors over the parameters governing the discrete
distributions.

µ2

µM

x1

x2

xM

Figure 8.12 As in Figure 8.11 but with a sin- µ1
gle set of parameters µ shared
amongst all of the conditional
distributions p(xi |xi−1 ).

x1

Section 2.4

µ

x2

xM

ter µi representing the probability p(xi = 1), giving M parameters in total for the
parent nodes. The conditional distribution p(y|x1 , . . . , xM ), however, would require
2M parameters representing the probability p(y = 1) for each of the 2M possible
settings of the parent variables. Thus in general the number of parameters required
to specify this conditional distribution will grow exponentially with M . We can obtain a more parsimonious form for the conditional distribution by using a logistic
sigmoid function acting on a linear combination of the parent variables, giving
M

p(y = 1|x1 , . . . , xM ) = σ

w0 +

wi xi

= σ(wT x)

(8.10)

i=1

where σ(a) = (1+exp(−a))−1 is the logistic sigmoid, x = (x0 , x1 , . . . , xM )T is an
(M + 1)-dimensional vector of parent states augmented with an additional variable
x0 whose value is clamped to 1, and w = (w0 , w1 , . . . , wM )T is a vector of M + 1
parameters. This is a more restricted form of conditional distribution than the general
case but is now governed by a number of parameters that grows linearly with M . In
this sense, it is analogous to the choice of a restrictive form of covariance matrix (for
example, a diagonal matrix) in a multivariate Gaussian distribution. The motivation
for the logistic sigmoid representation was discussed in Section 4.2.
Figure 8.13 A graph comprising M parents x1 , . . . , xM and a single child y, used to illustrate the idea of parameterized
conditional distributions for discrete variables.

x1

xM

y

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

370

8. GRAPHICAL MODELS

8.1.4 Linear-Gaussian models
In the previous section, we saw how to construct joint probability distributions
over a set of discrete variables by expressing the variables as nodes in a directed
acyclic graph. Here we show how a multivariate Gaussian can be expressed as a
directed graph corresponding to a linear-Gaussian model over the component variables. This allows us to impose interesting structure on the distribution, with the
general Gaussian and the diagonal covariance Gaussian representing opposite extremes. Several widely used techniques are examples of linear-Gaussian models,
such as probabilistic principal component analysis, factor analysis, and linear dynamical systems (Roweis and Ghahramani, 1999). We shall make extensive use of
the results of this section in later chapters when we consider some of these techniques
in detail.
Consider an arbitrary directed acyclic graph over D variables in which node i
represents a single continuous random variable xi having a Gaussian distribution.
The mean of this distribution is taken to be a linear combination of the states of its
parent nodes pai of node i


p(xi |pai ) = N xi

j∈pai

wij xj + bi , vi 

(8.11)

where wij and bi are parameters governing the mean, and vi is the variance of the
conditional distribution for xi . The log of the joint distribution is then the log of the
product of these conditionals over all nodes in the graph and hence takes the form
D

ln p(x) =
i=1

ln p(xi |pai )

D

= −

i=1


1 
xi −
2vi

(8.12)

j∈pai

2

wij xj − bi  + const

(8.13)

where x = (x1 , . . . , xD )T and ‘const’ denotes terms independent of x. We see that
this is a quadratic function of the components of x, and hence the joint distribution
p(x) is a multivariate Gaussian.
We can determine the mean and covariance of the joint distribution recursively
as follows. Each variable xi has (conditional on the states of its parents) a Gaussian
distribution of the form (8.11) and so
√
(8.14)
xi =
wij xj + bi + vi i
j∈pai

where i is a zero mean, unit variance Gaussian random variable satisfying E[ i ] = 0
and E[ i j ] = Iij , where Iij is the i, j element of the identity matrix. Taking the
expectation of (8.14), we have
E[xi ] =

wij E[xj ] + bi .

(8.15)

j∈pai

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

371

8.1. Bayesian Networks
Figure 8.14 A directed graph over three Gaussian variables,
with one missing link.

x1

x2

x3

Thus we can find the components of E[x] = (E[x1 ], . . . , E[xD ])T by starting at the
lowest numbered node and working recursively through the graph (here we again
assume that the nodes are numbered such that each node has a higher number than
its parents). Similarly, we can use (8.14) and (8.15) to obtain the i, j element of the
covariance matrix for p(x) in the form of a recursion relation
cov[xi , xj ] = E [(xi − E[xi ])(xj − E[xj ])]





√

wjk (xk − E[xk ]) + vj j 
= E (xi − E[xi ])


k∈paj

=

wjk cov[xi , xk ] + Iij vj

(8.16)

k∈paj

Section 2.3

Exercise 8.7

and so the covariance can similarly be evaluated recursively starting from the lowest
numbered node.
Let us consider two extreme cases. First of all, suppose that there are no links
in the graph, which therefore comprises D isolated nodes. In this case, there are no
parameters wij and so there are just D parameters bi and D parameters vi . From
the recursion relations (8.15) and (8.16), we see that the mean of p(x) is given by
(b1 , . . . , bD )T and the covariance matrix is diagonal of the form diag(v1 , . . . , vD ).
The joint distribution has a total of 2D parameters and represents a set of D independent univariate Gaussian distributions.
Now consider a fully connected graph in which each node has all lower numbered nodes as parents. The matrix wij then has i − 1 entries on the ith row and
hence is a lower triangular matrix (with no entries on the leading diagonal). Then
the total number of parameters wij is obtained by taking the number D2 of elements
in a D × D matrix, subtracting D to account for the absence of elements on the leading diagonal, and then dividing by 2 because the matrix has elements only below the
diagonal, giving a total of D(D − 1)/2. The total number of independent parameters
{wij } and {vi } in the covariance matrix is therefore D(D + 1)/2 corresponding to
a general symmetric covariance matrix.
Graphs having some intermediate level of complexity correspond to joint Gaussian
distributions with partially constrained covariance matrices. Consider for example
the graph shown in Figure 8.14, which has a link missing between variables x1 and
x3 .
Using the recursion relations (8.15) and (8.16), we see that the mean and
covariance of the joint distribution are given by
T

µ = (b1 , b2 + w21 b1 , b3 + w32 b2 + w32 w21 b1 )
v1
w21 v1
w32 w21 v1
2
2
w21 v1
v2 + w21
v1
w32 (v2 + w21
v1 )
Σ =
2
2
2
w32 w21 v1 w32 (v2 + w21 v1 ) v3 + w32 (v2 + w21
v1 )

(8.17)
. (8.18)

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

372

8. GRAPHICAL MODELS
We can readily extend the linear-Gaussian graphical model to the case in which
the nodes of the graph represent multivariate Gaussian variables. In this case, we can
write the conditional distribution for node i in the form


p(xi |pai ) = N xi

Section 2.3.6

j∈pai

Wij xj + bi , Σi 

(8.19)

where now Wij is a matrix (which is nonsquare if xi and xj have different dimensionalities). Again it is easy to verify that the joint distribution over all variables is
Gaussian.
Note that we have already encountered a specific example of the linear-Gaussian
relationship when we saw that the conjugate prior for the mean µ of a Gaussian
variable x is itself a Gaussian distribution over µ. The joint distribution over x and
µ is therefore Gaussian. This corresponds to a simple two-node graph in which
the node representing µ is the parent of the node representing x. The mean of the
distribution over µ is a parameter controlling a prior, and so it can be viewed as a
hyperparameter. Because the value of this hyperparameter may itself be unknown,
we can again treat it from a Bayesian perspective by introducing a prior over the
hyperparameter, sometimes called a hyperprior, which is again given by a Gaussian
distribution. This type of construction can be extended in principle to any level and is
an illustration of a hierarchical Bayesian model, of which we shall encounter further
examples in later chapters.

8.2. Conditional Independence
An important concept for probability distributions over multiple variables is that of
conditional independence (Dawid, 1980). Consider three variables a, b, and c, and
suppose that the conditional distribution of a, given b and c, is such that it does not
depend on the value of b, so that
p(a|b, c) = p(a|c).

(8.20)

We say that a is conditionally independent of b given c. This can be expressed in a
slightly different way if we consider the joint distribution of a and b conditioned on
c, which we can write in the form
p(a, b|c) = p(a|b, c)p(b|c)
= p(a|c)p(b|c).

(8.21)

where we have used the product rule of probability together with (8.20). Thus we
see that, conditioned on c, the joint distribution of a and b factorizes into the product of the marginal distribution of a and the marginal distribution of b (again both
conditioned on c). This says that the variables a and b are statistically independent,
given c. Note that our definition of conditional independence will require that (8.20),

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.2. Conditional Independence

373

c

Figure 8.15 The first of three examples of graphs over three variables
a, b, and c used to discuss conditional independence
properties of directed graphical models.

a

b

or equivalently (8.21), must hold for every possible value of c, and not just for some
values. We shall sometimes use a shorthand notation for conditional independence
(Dawid, 1979) in which
a⊥
⊥b|c
(8.22)

denotes that a is conditionally independent of b given c and is equivalent to (8.20).
Conditional independence properties play an important role in using probabilistic models for pattern recognition by simplifying both the structure of a model and
the computations needed to perform inference and learning under that model. We
shall see examples of this shortly.
If we are given an expression for the joint distribution over a set of variables in
terms of a product of conditional distributions (i.e., the mathematical representation
underlying a directed graph), then we could in principle test whether any potential conditional independence property holds by repeated application of the sum and
product rules of probability. In practice, such an approach would be very time consuming. An important and elegant feature of graphical models is that conditional
independence properties of the joint distribution can be read directly from the graph
without having to perform any analytical manipulations. The general framework
for achieving this is called d-separation, where the ‘d’ stands for ‘directed’ (Pearl,
1988). Here we shall motivate the concept of d-separation and give a general statement of the d-separation criterion. A formal proof can be found in Lauritzen (1996).

8.2.1 Three example graphs
We begin our discussion of the conditional independence properties of directed
graphs by considering three simple examples each involving graphs having just three
nodes. Together, these will motivate and illustrate the key concepts of d-separation.
The first of the three examples is shown in Figure 8.15, and the joint distribution
corresponding to this graph is easily written down using the general result (8.5) to
give
p(a, b, c) = p(a|c)p(b|c)p(c).
(8.23)
If none of the variables are observed, then we can investigate whether a and b are
independent by marginalizing both sides of (8.23) with respect to c to give
p(a, b) =

p(a|c)p(b|c)p(c).

(8.24)

c

In general, this does not factorize into the product p(a)p(b), and so
a⊥
⊥b|∅

(8.25)

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

374

8. GRAPHICAL MODELS
c

Figure 8.16 As in Figure 8.15 but where we have conditioned on the
value of variable c.

a

b

where ∅ denotes the empty set, and the symbol ⊥
⊥ means that the conditional independence property does not hold in general. Of course, it may hold for a particular
distribution by virtue of the specific numerical values associated with the various
conditional probabilities, but it does not follow in general from the structure of the
graph.
Now suppose we condition on the variable c, as represented by the graph of
Figure 8.16. From (8.23), we can easily write down the conditional distribution of
a and b, given c, in the form
p(a, b, c)
p(c)
= p(a|c)p(b|c)

p(a, b|c) =

and so we obtain the conditional independence property
a⊥
⊥ b | c.
We can provide a simple graphical interpretation of this result by considering
the path from node a to node b via c. The node c is said to be tail-to-tail with respect to this path because the node is connected to the tails of the two arrows, and
the presence of such a path connecting nodes a and b causes these nodes to be dependent. However, when we condition on node c, as in Figure 8.16, the conditioned
node ‘blocks’ the path from a to b and causes a and b to become (conditionally)
independent.
We can similarly consider the graph shown in Figure 8.17. The joint distribution corresponding to this graph is again obtained from our general formula (8.5) to
give
p(a, b, c) = p(a)p(c|a)p(b|c).
(8.26)
First of all, suppose that none of the variables are observed. Again, we can test to
see if a and b are independent by marginalizing over c to give
p(a, b) = p(a)

p(c|a)p(b|c) = p(a)p(b|a).
c

Figure 8.17 The second of our three examples of 3-node a
graphs used to motivate the conditional independence framework for directed graphical models.

c

b

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.2. Conditional Independence
Figure 8.18 As in Figure 8.17 but now conditioning on node c.

a

c

375
b

which in general does not factorize into p(a)p(b), and so
a⊥
⊥b|∅

(8.27)

as before.
Now suppose we condition on node c, as shown in Figure 8.18.
theorem, together with (8.26), we obtain

Using Bayes’

p(a, b, c)
p(c)
p(a)p(c|a)p(b|c)
=
p(c)
= p(a|c)p(b|c)

p(a, b|c) =

and so again we obtain the conditional independence property
a⊥
⊥ b | c.
As before, we can interpret these results graphically. The node c is said to be
head-to-tail with respect to the path from node a to node b. Such a path connects
nodes a and b and renders them dependent. If we now observe c, as in Figure 8.18,
then this observation ‘blocks’ the path from a to b and so we obtain the conditional
independence property a ⊥
⊥ b | c.
Finally, we consider the third of our 3-node examples, shown by the graph in
Figure 8.19.
As we shall see, this has a more subtle behaviour than the two
previous graphs.
The joint distribution can again be written down using our general result (8.5) to
give
p(a, b, c) = p(a)p(b)p(c|a, b).
(8.28)
Consider first the case where none of the variables are observed. Marginalizing both
sides of (8.28) over c we obtain
p(a, b) = p(a)p(b)
Figure 8.19 The last of our three examples of 3-node graphs used to a
explore conditional independence properties in graphical models. This graph has rather different properties
from the two previous examples.

b

c

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

376

8. GRAPHICAL MODELS
Figure 8.20 As in Figure 8.19 but conditioning on the value of node a
c. In this graph, the act of conditioning induces a dependence between a and b.

b

c

and so a and b are independent with no variables observed, in contrast to the two
previous examples. We can write this result as
a⊥
⊥ b | ∅.
Now suppose we condition on c, as indicated in Figure 8.20.
distribution of a and b is then given by
p(a, b|c) =
=

(8.29)
The conditional

p(a, b, c)
p(c)
p(a)p(b)p(c|a, b)
p(c)

which in general does not factorize into the product p(a)p(b), and so
a⊥
⊥ b | c.

Exercise 8.10

Thus our third example has the opposite behaviour from the first two. Graphically,
we say that node c is head-to-head with respect to the path from a to b because it
connects to the heads of the two arrows. When node c is unobserved, it ‘blocks’
the path, and the variables a and b are independent. However, conditioning on c
‘unblocks’ the path and renders a and b dependent.
There is one more subtlety associated with this third example that we need to
consider. First we introduce some more terminology. We say that node y is a descendant of node x if there is a path from x to y in which each step of the path
follows the directions of the arrows. Then it can be shown that a head-to-head path
will become unblocked if either the node, or any of its descendants, is observed.
In summary, a tail-to-tail node or a head-to-tail node leaves a path unblocked
unless it is observed in which case it blocks the path. By contrast, a head-to-head
node blocks a path if it is unobserved, but once the node, and/or at least one of its
descendants, is observed the path becomes unblocked.
It is worth spending a moment to understand further the unusual behaviour of the
graph of Figure 8.20. Consider a particular instance of such a graph corresponding
to a problem with three binary random variables relating to the fuel system on a car,
as shown in Figure 8.21.
The variables are called B, representing the state of a
battery that is either charged (B = 1) or flat (B = 0), F representing the state of
the fuel tank that is either full of fuel (F = 1) or empty (F = 0), and G, which is
the state of an electric fuel gauge and which indicates either full (G = 1) or empty

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

377

8.2. Conditional Independence
B

F

B

F

G

B

G

F

G

Figure 8.21 An example of a 3-node graph used to illustrate the phenomenon of ‘explaining away’. The three
nodes represent the state of the battery (B), the state of the fuel tank (F ) and the reading on the electric fuel
gauge (G). See the text for details.

(G = 0). The battery is either charged or flat, and independently the fuel tank is
either full or empty, with prior probabilities
p(B = 1) = 0.9
p(F = 1) = 0.9.
Given the state of the fuel tank and the battery, the fuel gauge reads full with probabilities given by
p(G = 1|B
p(G = 1|B
p(G = 1|B
p(G = 1|B

= 1, F
= 1, F
= 0, F
= 0, F

= 1)
= 0)
= 1)
= 0)

=
=
=
=

0.8
0.2
0.2
0.1

so this is a rather unreliable fuel gauge! All remaining probabilities are determined
by the requirement that probabilities sum to one, and so we have a complete specification of the probabilistic model.
Before we observe any data, the prior probability of the fuel tank being empty
is p(F = 0) = 0.1. Now suppose that we observe the fuel gauge and discover that
it reads empty, i.e., G = 0, corresponding to the middle graph in Figure 8.21. We
can use Bayes’ theorem to evaluate the posterior probability of the fuel tank being
empty. First we evaluate the denominator for Bayes’ theorem given by
p(G = 0) =

p(G = 0|B, F )p(B)p(F ) = 0.315

(8.30)

p(G = 0|B, F = 0)p(B) = 0.81

(8.31)

B∈{0,1} F ∈{0,1}

and similarly we evaluate
p(G = 0|F = 0) =
B∈{0,1}

and using these results we have
p(F = 0|G = 0) =

p(G = 0|F = 0)p(F = 0)
p(G = 0)

0.257

(8.32)

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

378

8. GRAPHICAL MODELS
and so p(F = 0|G = 0) > p(F = 0). Thus observing that the gauge reads empty
makes it more likely that the tank is indeed empty, as we would intuitively expect.
Next suppose that we also check the state of the battery and find that it is flat, i.e.,
B = 0. We have now observed the states of both the fuel gauge and the battery, as
shown by the right-hand graph in Figure 8.21. The posterior probability that the fuel
tank is empty given the observations of both the fuel gauge and the battery state is
then given by
p(F = 0|G = 0, B = 0) =

p(G = 0|B = 0, F = 0)p(F = 0)
F ∈{0,1} p(G = 0|B = 0, F )p(F )

0.111 (8.33)

where the prior probability p(B = 0) has cancelled between numerator and denominator. Thus the probability that the tank is empty has decreased (from 0.257 to
0.111) as a result of the observation of the state of the battery. This accords with our
intuition that finding out that the battery is flat explains away the observation that the
fuel gauge reads empty. We see that the state of the fuel tank and that of the battery
have indeed become dependent on each other as a result of observing the reading
on the fuel gauge. In fact, this would also be the case if, instead of observing the
fuel gauge directly, we observed the state of some descendant of G. Note that the
probability p(F = 0|G = 0, B = 0)
0.111 is greater than the prior probability
p(F = 0) = 0.1 because the observation that the fuel gauge reads zero still provides
some evidence in favour of an empty fuel tank.

8.2.2 D-separation
We now give a general statement of the d-separation property (Pearl, 1988) for
directed graphs. Consider a general directed graph in which A, B, and C are arbitrary nonintersecting sets of nodes (whose union may be smaller than the complete
set of nodes in the graph). We wish to ascertain whether a particular conditional
independence statement A ⊥
⊥ B | C is implied by a given directed acyclic graph. To
do so, we consider all possible paths from any node in A to any node in B. Any such
path is said to be blocked if it includes a node such that either
(a) the arrows on the path meet either head-to-tail or tail-to-tail at the node, and the
node is in the set C, or
(b) the arrows meet head-to-head at the node, and neither the node, nor any of its
descendants, is in the set C.
If all paths are blocked, then A is said to be d-separated from B by C, and the joint
distribution over all of the variables in the graph will satisfy A ⊥
⊥ B | C.
The concept of d-separation is illustrated in Figure 8.22. In graph (a), the path
from a to b is not blocked by node f because it is a tail-to-tail node for this path
and is not observed, nor is it blocked by node e because, although the latter is a
head-to-head node, it has a descendant c because is in the conditioning set. Thus
the conditional independence statement a ⊥
⊥ b | c does not follow from this graph.
In graph (b), the path from a to b is blocked by node f because this is a tail-to-tail
node that is observed, and so the conditional independence property a ⊥
⊥ b | f will

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

379

8.2. Conditional Independence
Figure 8.22 Illustration of the concept of d-separation. See the text for
details.

f

a

e

f

a

e

b

c

b

c
(a)

Section 2.3

(b)

be satisfied by any distribution that factorizes according to this graph. Note that this
path is also blocked by node e because e is a head-to-head node and neither it nor its
descendant are in the conditioning set.
For the purposes of d-separation, parameters such as α and σ 2 in Figure 8.5,
indicated by small filled circles, behave in the same was as observed nodes. However, there are no marginal distributions associated with such nodes. Consequently
parameter nodes never themselves have parents and so all paths through these nodes
will always be tail-to-tail and hence blocked. Consequently they play no role in
d-separation.
Another example of conditional independence and d-separation is provided by
the concept of i.i.d. (independent identically distributed) data introduced in Section 1.2.4. Consider the problem of finding the posterior distribution for the mean
of a univariate Gaussian distribution. This can be represented by the directed graph
shown in Figure 8.23 in which the joint distribution is defined by a prior p(µ) together with a set of conditional distributions p(xn |µ) for n = 1, . . . , N . In practice,
we observe D = {x1 , . . . , xN } and our goal is to infer µ. Suppose, for a moment,
that we condition on µ and consider the joint distribution of the observations. Using
d-separation, we note that there is a unique path from any xi to any other xj =i and
that this path is tail-to-tail with respect to the observed node µ. Every such path is
blocked and so the observations D = {x1 , . . . , xN } are independent given µ, so that
N

p(D|µ) =
n=1

Figure 8.23 (a) Directed graph corresponding to the problem
of inferring the mean µ of
a univariate Gaussian distribution from observations
x1 , . . . , xN . (b) The same
graph drawn using the plate
notation.

p(xn |µ).

(8.34)

µ
µ
N
x1

xN
(a)

xn

N
(b)

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

380

8. GRAPHICAL MODELS
Figure 8.24 A graphical representation of the ‘naive Bayes’
model for classification.
Conditioned on the
class label z, the components of the observed
vector x = (x1 , . . . , xD )T are assumed to be
independent.

z

x1

xD

However, if we integrate over µ, the observations are in general no longer independent
N

∞

p(D|µ)p(µ) dµ =

p(D) =
0

p(xn ).

(8.35)

n=1

Here µ is a latent variable, because its value is not observed.
Another example of a model representing i.i.d. data is the graph in Figure 8.7
corresponding to Bayesian polynomial regression. Here the stochastic nodes correspond to {tn }, w and t. We see that the node for w is tail-to-tail with respect to
the path from t to any one of the nodes tn and so we have the following conditional
independence property
t⊥
⊥ tn | w.
(8.36)

Section 3.3

Thus, conditioned on the polynomial coefficients w, the predictive distribution for
t is independent of the training data {t1 , . . . , tN }. We can therefore first use the
training data to determine the posterior distribution over the coefficients w and then
we can discard the training data and use the posterior distribution for w to make
predictions of t for new input observations x.
A related graphical structure arises in an approach to classification called the
naive Bayes model, in which we use conditional independence assumptions to simplify the model structure. Suppose our observed variable consists of a D-dimensional
vector x = (x1 , . . . , xD )T , and we wish to assign observed values of x to one of K
classes. Using the 1-of-K encoding scheme, we can represent these classes by a Kdimensional binary vector z. We can then define a generative model by introducing
a multinomial prior p(z|µ) over the class labels, where the kth component µk of µ
is the prior probability of class Ck , together with a conditional distribution p(x|z)
for the observed vector x. The key assumption of the naive Bayes model is that,
conditioned on the class z, the distributions of the input variables x1 , . . . , xD are independent. The graphical representation of this model is shown in Figure 8.24. We
see that observation of z blocks the path between xi and xj for j = i (because such
paths are tail-to-tail at the node z) and so xi and xj are conditionally independent
given z. If, however, we marginalize out z (so that z is unobserved) the tail-to-tail
path from xi to xj is no longer blocked. This tells us that in general the marginal
density p(x) will not factorize with respect to the components of x. We encountered
a simple application of the naive Bayes model in the context of fusing data from
different sources for medical diagnosis in Section 1.5.
If we are given a labelled training set, comprising inputs {x1 , . . . , xN } together
with their class labels, then we can fit the naive Bayes model to the training data

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.2. Conditional Independence

381

using maximum likelihood assuming that the data are drawn independently from
the model. The solution is obtained by fitting the model for each class separately
using the correspondingly labelled data. As an example, suppose that the probability
density within each class is chosen to be Gaussian. In this case, the naive Bayes
assumption then implies that the covariance matrix for each Gaussian is diagonal,
and the contours of constant density within each class will be axis-aligned ellipsoids.
The marginal density, however, is given by a superposition of diagonal Gaussians
(with weighting coefficients given by the class priors) and so will no longer factorize
with respect to its components.
The naive Bayes assumption is helpful when the dimensionality D of the input
space is high, making density estimation in the full D-dimensional space more challenging. It is also useful if the input vector contains both discrete and continuous
variables, since each can be represented separately using appropriate models (e.g.,
Bernoulli distributions for binary observations or Gaussians for real-valued variables). The conditional independence assumption of this model is clearly a strong
one that may lead to rather poor representations of the class-conditional densities.
Nevertheless, even if this assumption is not precisely satisfied, the model may still
give good classification performance in practice because the decision boundaries can
be insensitive to some of the details in the class-conditional densities, as illustrated
in Figure 1.27.
We have seen that a particular directed graph represents a specific decomposition
of a joint probability distribution into a product of conditional probabilities. The
graph also expresses a set of conditional independence statements obtained through
the d-separation criterion, and the d-separation theorem is really an expression of the
equivalence of these two properties. In order to make this clear, it is helpful to think
of a directed graph as a filter. Suppose we consider a particular joint probability
distribution p(x) over the variables x corresponding to the (nonobserved) nodes of
the graph. The filter will allow this distribution to pass through if, and only if, it can
be expressed in terms of the factorization (8.5) implied by the graph. If we present to
the filter the set of all possible distributions p(x) over the set of variables x, then the
subset of distributions that are passed by the filter will be denoted DF , for directed
factorization. This is illustrated in Figure 8.25. Alternatively, we can use the
graph as a different kind of filter by first listing all of the conditional independence
properties obtained by applying the d-separation criterion to the graph, and then
allowing a distribution to pass only if it satisfies all of these properties. If we present
all possible distributions p(x) to this second kind of filter, then the d-separation
theorem tells us that the set of distributions that will be allowed through is precisely
the set DF .
It should be emphasized that the conditional independence properties obtained
from d-separation apply to any probabilistic model described by that particular directed graph. This will be true, for instance, whether the variables are discrete or
continuous or a combination of these. Again, we see that a particular graph is describing a whole family of probability distributions.
At one extreme we have a fully connected graph that exhibits no conditional independence properties at all, and which can represent any possible joint probability

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

382

8. GRAPHICAL MODELS

p(x)

DF

Figure 8.25 We can view a graphical model (in this case a directed graph) as a filter in which a probability distribution p(x) is allowed through the filter if, and only if, it satisfies the directed
factorization property (8.5). The set of all possible probability distributions p(x) that pass
through the filter is denoted DF. We can alternatively use the graph to filter distributions
according to whether they respect all of the conditional independencies implied by the
d-separation properties of the graph. The d-separation theorem says that it is the same
set of distributions DF that will be allowed through this second kind of filter.

distribution over the given variables. The set DF will contain all possible distributions p(x). At the other extreme, we have the fully disconnected graph, i.e., one
having no links at all. This corresponds to joint distributions which factorize into the
product of the marginal distributions over the variables comprising the nodes of the
graph.
Note that for any given graph, the set of distributions DF will include any distributions that have additional independence properties beyond those described by
the graph. For instance, a fully factorized distribution will always be passed through
the filter implied by any graph over the corresponding set of variables.
We end our discussion of conditional independence properties by exploring the
concept of a Markov blanket or Markov boundary. Consider a joint distribution
p(x1 , . . . , xD ) represented by a directed graph having D nodes, and consider the
conditional distribution of a particular node with variables xi conditioned on all of
the remaining variables xj =i . Using the factorization property (8.5), we can express
this conditional distribution in the form
p(xi |x{j =i} ) =

=

p(x1 , . . . , xD )
p(x1 , . . . , xD ) dxi

k

k

p(xk |pak )
p(xk |pak ) dxi

in which the integral is replaced by a summation in the case of discrete variables. We
now observe that any factor p(xk |pak ) that does not have any functional dependence
on xi can be taken outside the integral over xi , and will therefore cancel between
numerator and denominator. The only factors that remain will be the conditional
distribution p(xi |pai ) for node xi itself, together with the conditional distributions
for any nodes xk such that node xi is in the conditioning set of p(xk |pak ), in other
words for which xi is a parent of xk . The conditional p(xi |pai ) will depend on the

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.3. Markov Random Fields
Figure 8.26 The Markov blanket of a node xi comprises the set
of parents, children and co-parents of the node. It
has the property that the conditional distribution of
xi , conditioned on all the remaining variables in the
graph, is dependent only on the variables in the
Markov blanket.

383

xi

parents of node xi , whereas the conditionals p(xk |pak ) will depend on the children
of xi as well as on the co-parents, in other words variables corresponding to parents
of node xk other than node xi . The set of nodes comprising the parents, the children
and the co-parents is called the Markov blanket and is illustrated in Figure 8.26. We
can think of the Markov blanket of a node xi as being the minimal set of nodes that
isolates xi from the rest of the graph. Note that it is not sufficient to include only the
parents and children of node xi because the phenomenon of explaining away means
that observations of the child nodes will not block paths to the co-parents. We must
therefore observe the co-parent nodes also.

8.3. Markov Random Fields
We have seen that directed graphical models specify a factorization of the joint distribution over a set of variables into a product of local conditional distributions. They
also define a set of conditional independence properties that must be satisfied by any
distribution that factorizes according to the graph. We turn now to the second major class of graphical models that are described by undirected graphs and that again
specify both a factorization and a set of conditional independence relations.
A Markov random field, also known as a Markov network or an undirected
graphical model (Kindermann and Snell, 1980), has a set of nodes each of which
corresponds to a variable or group of variables, as well as a set of links each of
which connects a pair of nodes. The links are undirected, that is they do not carry
arrows. In the case of undirected graphs, it is convenient to begin with a discussion
of conditional independence properties.

8.3.1 Conditional independence properties
Section 8.2

In the case of directed graphs, we saw that it was possible to test whether a particular conditional independence property holds by applying a graphical test called
d-separation. This involved testing whether or not the paths connecting two sets of
nodes were ‘blocked’. The definition of blocked, however, was somewhat subtle
due to the presence of paths having head-to-head nodes. We might ask whether it
is possible to define an alternative graphical semantics for probability distributions
such that conditional independence is determined by simple graph separation. This

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

384

8. GRAPHICAL MODELS
Figure 8.27 An example of an undirected graph in
which every path from any node in set
A to any node in set B passes through
at least one node in set C. Consequently the conditional independence
property A ⊥
⊥ B | C holds for any
probability distribution described by this
graph.

C
B
A

is indeed the case and corresponds to undirected graphical models. By removing the
directionality from the links of the graph, the asymmetry between parent and child
nodes is removed, and so the subtleties associated with head-to-head nodes no longer
arise.
Suppose that in an undirected graph we identify three sets of nodes, denoted A,
B, and C, and that we consider the conditional independence property
A⊥
⊥ B | C.

(8.37)

To test whether this property is satisfied by a probability distribution defined by a
graph we consider all possible paths that connect nodes in set A to nodes in set B.
If all such paths pass through one or more nodes in set C, then all such paths are
‘blocked’ and so the conditional independence property holds. However, if there
is at least one such path that is not blocked, then the property does not necessarily
hold, or more precisely there will exist at least some distributions corresponding to
the graph that do not satisfy this conditional independence relation. This is illustrated with an example in Figure 8.27.
Note that this is exactly the same as the
d-separation criterion except that there is no ‘explaining away’ phenomenon. Testing for conditional independence in undirected graphs is therefore simpler than in
directed graphs.
An alternative way to view the conditional independence test is to imagine removing all nodes in set C from the graph together with any links that connect to
those nodes. We then ask if there exists a path that connects any node in A to any
node in B. If there are no such paths, then the conditional independence property
must hold.
The Markov blanket for an undirected graph takes a particularly simple form,
because a node will be conditionally independent of all other nodes conditioned only
on the neighbouring nodes, as illustrated in Figure 8.28.

8.3.2 Factorization properties
We now seek a factorization rule for undirected graphs that will correspond to
the above conditional independence test. Again, this will involve expressing the joint
distribution p(x) as a product of functions defined over sets of variables that are local

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.3. Markov Random Fields

385

Figure 8.28 For an undirected graph, the Markov blanket of a node
xi consists of the set of neighbouring nodes. It has the
property that the conditional distribution of xi , conditioned
on all the remaining variables in the graph, is dependent
only on the variables in the Markov blanket.

to the graph. We therefore need to decide what is the appropriate notion of locality
in this case.
If we consider two nodes xi and xj that are not connected by a link, then these
variables must be conditionally independent given all other nodes in the graph. This
follows from the fact that there is no direct path between the two nodes, and all other
paths pass through nodes that are observed, and hence those paths are blocked. This
conditional independence property can be expressed as
p(xi , xj |x\{i,j}) = p(xi |x\{i,j})p(xj |x\{i,j} )

(8.38)

where x\{i,j} denotes the set x of all variables with xi and xj removed. The factorization of the joint distribution must therefore be such that xi and xj do not appear
in the same factor in order for the conditional independence property to hold for all
possible distributions belonging to the graph.
This leads us to consider a graphical concept called a clique, which is defined
as a subset of the nodes in a graph such that there exists a link between all pairs of
nodes in the subset. In other words, the set of nodes in a clique is fully connected.
Furthermore, a maximal clique is a clique such that it is not possible to include any
other nodes from the graph in the set without it ceasing to be a clique. These concepts
are illustrated by the undirected graph over four variables shown in Figure 8.29.
This graph has five cliques of two nodes given by {x1 , x2 }, {x2 , x3 }, {x3 , x4 },
{x4 , x2 }, and {x1 , x3 }, as well as two maximal cliques given by {x1 , x2 , x3 } and
{x2 , x3 , x4 }. The set {x1 , x2 , x3 , x4 } is not a clique because of the missing link
from x1 to x4 .
We can therefore define the factors in the decomposition of the joint distribution
to be functions of the variables in the cliques. In fact, we can consider functions
of the maximal cliques, without loss of generality, because other cliques must be
subsets of maximal cliques. Thus, if {x1 , x2 , x3 } is a maximal clique and we define
Figure 8.29 A four-node undirected graph showing a clique (outlined in
green) and a maximal clique (outlined in blue).

x1
x2

x3
x4

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

386

8. GRAPHICAL MODELS
an arbitrary function over this clique, then including another factor defined over a
subset of these variables would be redundant.
Let us denote a clique by C and the set of variables in that clique by xC . Then
the joint distribution is written as a product of potential functions ψC (xC ) over the
maximal cliques of the graph
p(x) =

1
Z

ψC (xC ).

(8.39)

C

Here the quantity Z, sometimes called the partition function, is a normalization constant and is given by
Z=
ψC (xC )
(8.40)
x

C

which ensures that the distribution p(x) given by (8.39) is correctly normalized.
By considering only potential functions which satisfy ψC (xC )
0 we ensure that
p(x)
0. In (8.40) we have assumed that x comprises discrete variables, but the
framework is equally applicable to continuous variables, or a combination of the two,
in which the summation is replaced by the appropriate combination of summation
and integration.
Note that we do not restrict the choice of potential functions to those that have a
specific probabilistic interpretation as marginal or conditional distributions. This is
in contrast to directed graphs in which each factor represents the conditional distribution of the corresponding variable, conditioned on the state of its parents. However,
in special cases, for instance where the undirected graph is constructed by starting
with a directed graph, the potential functions may indeed have such an interpretation,
as we shall see shortly.
One consequence of the generality of the potential functions ψC (xC ) is that
their product will in general not be correctly normalized. We therefore have to introduce an explicit normalization factor given by (8.40). Recall that for directed
graphs, the joint distribution was automatically normalized as a consequence of the
normalization of each of the conditional distributions in the factorization.
The presence of this normalization constant is one of the major limitations of
undirected graphs. If we have a model with M discrete nodes each having K states,
then the evaluation of the normalization term involves summing over K M states and
so (in the worst case) is exponential in the size of the model. The partition function
is needed for parameter learning because it will be a function of any parameters that
govern the potential functions ψC (xC ). However, for evaluation of local conditional
distributions, the partition function is not needed because a conditional is the ratio of
two marginals, and the partition function cancels between numerator and denominator when evaluating this ratio. Similarly, for evaluating local marginal probabilities
we can work with the unnormalized joint distribution and then normalize the marginals explicitly at the end. Provided the marginals only involves a small number of
variables, the evaluation of their normalization coefficient will be feasible.
So far, we have discussed the notion of conditional independence based on simple graph separation and we have proposed a factorization of the joint distribution

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.3. Markov Random Fields

387

that is intended to correspond to this conditional independence structure. However,
we have not made any formal connection between conditional independence and
factorization for undirected graphs. To do so we need to restrict attention to potential functions ψC (xC ) that are strictly positive (i.e., never zero or negative for any
choice of xC ). Given this restriction, we can make a precise relationship between
factorization and conditional independence.
To do this we again return to the concept of a graphical model as a filter, corresponding to Figure 8.25. Consider the set of all possible distributions defined over
a fixed set of variables corresponding to the nodes of a particular undirected graph.
We can define U I to be the set of such distributions that are consistent with the set
of conditional independence statements that can be read from the graph using graph
separation. Similarly, we can define U F to be the set of such distributions that can
be expressed as a factorization of the form (8.39) with respect to the maximal cliques
of the graph. The Hammersley-Clifford theorem (Clifford, 1990) states that the sets
U I and U F are identical.
Because we are restricted to potential functions which are strictly positive it is
convenient to express them as exponentials, so that
ψC (xC ) = exp {−E(xC )}

(8.41)

where E(xC ) is called an energy function, and the exponential representation is
called the Boltzmann distribution. The joint distribution is defined as the product of
potentials, and so the total energy is obtained by adding the energies of each of the
maximal cliques.
In contrast to the factors in the joint distribution for a directed graph, the potentials in an undirected graph do not have a specific probabilistic interpretation.
Although this gives greater flexibility in choosing the potential functions, because
there is no normalization constraint, it does raise the question of how to motivate a
choice of potential function for a particular application. This can be done by viewing the potential function as expressing which configurations of the local variables
are preferred to others. Global configurations that have a relatively high probability
are those that find a good balance in satisfying the (possibly conflicting) influences
of the clique potentials. We turn now to a specific example to illustrate the use of
undirected graphs.

8.3.3 Illustration: Image de-noising
We can illustrate the application of undirected graphs using an example of noise
removal from a binary image (Besag, 1974; Geman and Geman, 1984; Besag, 1986).
Although a very simple example, this is typical of more sophisticated applications.
Let the observed noisy image be described by an array of binary pixel values yi ∈
{−1, +1}, where the index i = 1, . . . , D runs over all pixels. We shall suppose
that the image is obtained by taking an unknown noise-free image, described by
binary pixel values xi ∈ {−1, +1} and randomly flipping the sign of pixels with
some small probability. An example binary image, together with a noise corrupted
image obtained by flipping the sign of the pixels with probability 10%, is shown in

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

388

8. GRAPHICAL MODELS

Figure 8.30 Illustration of image de-noising using a Markov random field. The top row shows the original
binary image on the left and the corrupted image after randomly changing 10% of the pixels on the right. The
bottom row shows the restored images obtained using iterated conditional models (ICM) on the left and using
the graph-cut algorithm on the right. ICM produces an image where 96% of the pixels agree with the original
image, whereas the corresponding number for graph-cut is 99%.

Figure 8.30. Given the noisy image, our goal is to recover the original noise-free
image.
Because the noise level is small, we know that there will be a strong correlation
between xi and yi . We also know that neighbouring pixels xi and xj in an image are
strongly correlated. This prior knowledge can be captured using the Markov random
field model whose undirected graph is shown in Figure 8.31.
This graph has
two types of cliques, each of which contains two variables. The cliques of the form
{xi , yi } have an associated energy function that expresses the correlation between
these variables. We choose a very simple energy function for these cliques of the
form −ηxi yi where η is a positive constant. This has the desired effect of giving a
lower energy (thus encouraging a higher probability) when xi and yi have the same
sign and a higher energy when they have the opposite sign.
The remaining cliques comprise pairs of variables {xi , xj } where i and j are

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.3. Markov Random Fields
Figure 8.31 An undirected graphical model representing a
Markov random field for image de-noising, in
which xi is a binary variable denoting the state
of pixel i in the unknown noise-free image, and yi
denotes the corresponding value of pixel i in the
observed noisy image.

389

yi

xi

indices of neighbouring pixels. Again, we want the energy to be lower when the
pixels have the same sign than when they have the opposite sign, and so we choose
an energy given by −βxi xj where β is a positive constant.
Because a potential function is an arbitrary, nonnegative function over a maximal
clique, we can multiply it by any nonnegative functions of subsets of the clique, or
equivalently we can add the corresponding energies. In this example, this allows us
to add an extra term hxi for each pixel i in the noise-free image. Such a term has
the effect of biasing the model towards pixel values that have one particular sign in
preference to the other.
The complete energy function for the model then takes the form
E(x, y) = h
i

xi − β

{i,j}

xi xj − η

xi y i

(8.42)

i

which defines a joint distribution over x and y given by
p(x, y) =

Exercise 8.13

1
exp{−E(x, y)}.
Z

(8.43)

We now fix the elements of y to the observed values given by the pixels of the
noisy image, which implicitly defines a conditional distribution p(x|y) over noisefree images. This is an example of the Ising model, which has been widely studied in
statistical physics. For the purposes of image restoration, we wish to find an image x
having a high probability (ideally the maximum probability). To do this we shall use
a simple iterative technique called iterated conditional modes, or ICM (Kittler and
F¨
oglein, 1984), which is simply an application of coordinate-wise gradient ascent.
The idea is first to initialize the variables {xi }, which we do by simply setting xi =
yi for all i. Then we take one node xj at a time and we evaluate the total energy
for the two possible states xj = +1 and xj = −1, keeping all other node variables
fixed, and set xj to whichever state has the lower energy. This will either leave
the probability unchanged, if xj is unchanged, or will increase it. Because only
one variable is changed, this is a simple local computation that can be performed
efficiently. We then repeat the update for another site, and so on, until some suitable
stopping criterion is satisfied. The nodes may be updated in a systematic way, for

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

390

8. GRAPHICAL MODELS

x1
Figure 8.32 (a) Example of a directed
graph.
(b) The equivalent undirected (a)
graph.

x2

xN −1

xN

x1

x2

xN

xN −1

(b)

Exercise 8.14
Section 8.4

instance by repeatedly raster scanning through the image, or by choosing nodes at
random.
If we have a sequence of updates in which every site is visited at least once,
and in which no changes to the variables are made, then by definition the algorithm
will have converged to a local maximum of the probability. This need not, however,
correspond to the global maximum.
For the purposes of this simple illustration, we have fixed the parameters to be
β = 1.0, η = 2.1 and h = 0. Note that leaving h = 0 simply means that the prior
probabilities of the two states of xi are equal. Starting with the observed noisy image
as the initial configuration, we run ICM until convergence, leading to the de-noised
image shown in the lower left panel of Figure 8.30. Note that if we set β = 0,
which effectively removes the links between neighbouring pixels, then the global
most probable solution is given by xi = yi for all i, corresponding to the observed
noisy image.
Later we shall discuss a more effective algorithm for finding high probability solutions called the max-product algorithm, which typically leads to better solutions,
although this is still not guaranteed to find the global maximum of the posterior distribution. However, for certain classes of model, including the one given by (8.42),
there exist efficient algorithms based on graph cuts that are guaranteed to find the
global maximum (Greig et al., 1989; Boykov et al., 2001; Kolmogorov and Zabih,
2004). The lower right panel of Figure 8.30 shows the result of applying a graph-cut
algorithm to the de-noising problem.

8.3.4 Relation to directed graphs
We have introduced two graphical frameworks for representing probability distributions, corresponding to directed and undirected graphs, and it is instructive to
discuss the relation between these. Consider first the problem of taking a model that
is specified using a directed graph and trying to convert it to an undirected graph. In
some cases this is straightforward, as in the simple example in Figure 8.32. Here
the joint distribution for the directed graph is given as a product of conditionals in
the form
p(x) = p(x1 )p(x2 |x1 )p(x3 |x2 ) · · · p(xN |xN −1 ).
(8.44)
Now let us convert this to an undirected graph representation, as shown in Figure 8.32. In the undirected graph, the maximal cliques are simply the pairs of neighbouring nodes, and so from (8.39) we wish to write the joint distribution in the form
p(x) =

1
ψ1,2 (x1 , x2 )ψ2,3 (x2 , x3 ) · · · ψN −1,N (xN −1 , xN ).
Z

(8.45)

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

391

8.3. Markov Random Fields
Figure 8.33 Example of a simple
directed graph (a) and the corresponding moral graph (b).

x1

x3

x1

x2

x3
x2

x4
(a)

x4
(b)

This is easily done by identifying
ψ1,2 (x1 , x2 ) = p(x1 )p(x2 |x1 )
ψ2,3 (x2 , x3 ) = p(x3 |x2 )
.
.
.
ψN −1,N (xN −1 , xN ) = p(xN |xN −1 )
where we have absorbed the marginal p(x1 ) for the first node into the first potential
function. Note that in this case, the partition function Z = 1.
Let us consider how to generalize this construction, so that we can convert any
distribution specified by a factorization over a directed graph into one specified by a
factorization over an undirected graph. This can be achieved if the clique potentials
of the undirected graph are given by the conditional distributions of the directed
graph. In order for this to be valid, we must ensure that the set of variables that
appears in each of the conditional distributions is a member of at least one clique of
the undirected graph. For nodes on the directed graph having just one parent, this is
achieved simply by replacing the directed link with an undirected link. However, for
nodes in the directed graph having more than one parent, this is not sufficient. These
are nodes that have ‘head-to-head’ paths encountered in our discussion of conditional
independence. Consider a simple directed graph over 4 nodes shown in Figure 8.33.
The joint distribution for the directed graph takes the form
p(x) = p(x1 )p(x2 )p(x3 )p(x4 |x1 , x2 , x3 ).

(8.46)

We see that the factor p(x4 |x1 , x2 , x3 ) involves the four variables x1 , x2 , x3 , and
x4 , and so these must all belong to a single clique if this conditional distribution is
to be absorbed into a clique potential. To ensure this, we add extra links between
all pairs of parents of the node x4 . Anachronistically, this process of ‘marrying
the parents’ has become known as moralization, and the resulting undirected graph,
after dropping the arrows, is called the moral graph. It is important to observe that
the moral graph in this example is fully connected and so exhibits no conditional
independence properties, in contrast to the original directed graph.
Thus in general to convert a directed graph into an undirected graph, we first add
additional undirected links between all pairs of parents for each node in the graph and

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

392

8. GRAPHICAL MODELS

Section 8.4

Section 8.2

then drop the arrows on the original links to give the moral graph. Then we initialize
all of the clique potentials of the moral graph to 1. We then take each conditional
distribution factor in the original directed graph and multiply it into one of the clique
potentials. There will always exist at least one maximal clique that contains all of
the variables in the factor as a result of the moralization step. Note that in all cases
the partition function is given by Z = 1.
The process of converting a directed graph into an undirected graph plays an
important role in exact inference techniques such as the junction tree algorithm.
Converting from an undirected to a directed representation is much less common
and in general presents problems due to the normalization constraints.
We saw that in going from a directed to an undirected representation we had to
discard some conditional independence properties from the graph. Of course, we
could always trivially convert any distribution over a directed graph into one over an
undirected graph by simply using a fully connected undirected graph. This would,
however, discard all conditional independence properties and so would be vacuous.
The process of moralization adds the fewest extra links and so retains the maximum
number of independence properties.
We have seen that the procedure for determining the conditional independence
properties is different between directed and undirected graphs. It turns out that the
two types of graph can express different conditional independence properties, and
it is worth exploring this issue in more detail. To do so, we return to the view of
a specific (directed or undirected) graph as a filter, so that the set of all possible
distributions over the given variables could be reduced to a subset that respects the
conditional independencies implied by the graph. A graph is said to be a D map
(for ‘dependency map’) of a distribution if every conditional independence statement
satisfied by the distribution is reflected in the graph. Thus a completely disconnected
graph (no links) will be a trivial D map for any distribution.
Alternatively, we can consider a specific distribution and ask which graphs have
the appropriate conditional independence properties. If every conditional independence statement implied by a graph is satisfied by a specific distribution, then the
graph is said to be an I map (for ‘independence map’) of that distribution. Clearly a
fully connected graph will be a trivial I map for any distribution.
If it is the case that every conditional independence property of the distribution
is reflected in the graph, and vice versa, then the graph is said to be a perfect map for

Figure 8.34 Venn diagram illustrating the set of all distributions
P over a given set of variables, together with the
set of distributions D that can be represented as a
perfect map using a directed graph, and the set U
that can be represented as a perfect map using an
undirected graph.

D

U

P

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

393

8.4. Inference in Graphical Models
Figure 8.35 A directed graph whose conditional independence
properties cannot be expressed using an undirected
graph over the same three variables.

A

B

C

that distribution. A perfect map is therefore both an I map and a D map.
Consider the set of distributions such that for each distribution there exists a
directed graph that is a perfect map. This set is distinct from the set of distributions
such that for each distribution there exists an undirected graph that is a perfect map.
In addition there are distributions for which neither directed nor undirected graphs
offer a perfect map. This is illustrated as a Venn diagram in Figure 8.34.
Figure 8.35 shows an example of a directed graph that is a perfect map for
a distribution satisfying the conditional independence properties A ⊥
⊥ B | ∅ and
A⊥
⊥ B | C.
There is no corresponding undirected graph over the same three
variables that is a perfect map.
Conversely, consider the undirected graph over four variables shown in Figure 8.36. This graph exhibits the properties A ⊥
⊥ B | ∅, C ⊥
⊥ D | A ∪ B and
A⊥
⊥ B | C ∪ D. There is no directed graph over four variables that implies the same
set of conditional independence properties.
The graphical framework can be extended in a consistent way to graphs that
include both directed and undirected links. These are called chain graphs (Lauritzen
and Wermuth, 1989; Frydenberg, 1990), and contain the directed and undirected
graphs considered so far as special cases. Although such graphs can represent a
broader class of distributions than either directed or undirected alone, there remain
distributions for which even a chain graph cannot provide a perfect map. Chain
graphs are not discussed further in this book.
C

Figure 8.36 An undirected graph whose conditional independence
properties cannot be expressed in terms of a directed
graph over the same variables.

A

B

D

8.4. Inference in Graphical Models
We turn now to the problem of inference in graphical models, in which some of
the nodes in a graph are clamped to observed values, and we wish to compute the
posterior distributions of one or more subsets of other nodes. As we shall see, we
can exploit the graphical structure both to find efficient algorithms for inference, and

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

394

8. GRAPHICAL MODELS
Figure 8.37 A graphical representation of Bayes’ theorem. x
See the text for details.

x

x

y

y

y

(a)

(b)

(c)

to make the structure of those algorithms transparent. Specifically, we shall see that
many algorithms can be expressed in terms of the propagation of local messages
around the graph. In this section, we shall focus primarily on techniques for exact
inference, and in Chapter 10 we shall consider a number of approximate inference
algorithms.
To start with, let us consider the graphical interpretation of Bayes’ theorem.
Suppose we decompose the joint distribution p(x, y) over two variables x and y into
a product of factors in the form p(x, y) = p(x)p(y|x). This can be represented by
the directed graph shown in Figure 8.37(a).
Now suppose we observe the value
of y, as indicated by the shaded node in Figure 8.37(b). We can view the marginal
distribution p(x) as a prior over the latent variable x, and our goal is to infer the
corresponding posterior distribution over x. Using the sum and product rules of
probability we can evaluate
p(y) =

p(y|x )p(x )

(8.47)

x

which can then be used in Bayes’ theorem to calculate
p(x|y) =

p(y|x)p(x)
.
p(y)

(8.48)

Thus the joint distribution is now expressed in terms of p(y) and p(x|y). From a
graphical perspective, the joint distribution p(x, y) is now represented by the graph
shown in Figure 8.37(c), in which the direction of the arrow is reversed. This is the
simplest example of an inference problem for a graphical model.

8.4.1 Inference on a chain
Now consider a more complex problem involving the chain of nodes of the form
shown in Figure 8.32. This example will lay the foundation for a discussion of exact
inference in more general graphs later in this section.
Specifically, we shall consider the undirected graph in Figure 8.32(b). We have
already seen that the directed chain can be transformed into an equivalent undirected
chain. Because the directed graph does not have any nodes with more than one
parent, this does not require the addition of any extra links, and the directed and
undirected versions of this graph express exactly the same set of conditional independence statements.

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.4. Inference in Graphical Models

395

The joint distribution for this graph takes the form
p(x) =

1
ψ1,2 (x1 , x2 )ψ2,3 (x2 , x3 ) · · · ψN −1,N (xN −1 , xN ).
Z

(8.49)

We shall consider the specific case in which the N nodes represent discrete variables each having K states, in which case each potential function ψn−1,n (xn−1 , xn )
comprises an K × K table, and so the joint distribution has (N − 1)K 2 parameters.
Let us consider the inference problem of finding the marginal distribution p(xn )
for a specific node xn that is part way along the chain. Note that, for the moment,
there are no observed nodes. By definition, the required marginal is obtained by
summing the joint distribution over all variables except xn , so that
p(xn ) =
x1

···

xn−1 xn+1

···

p(x).

(8.50)

xN

In a naive implementation, we would first evaluate the joint distribution and
then perform the summations explicitly. The joint distribution can be represented as
a set of numbers, one for each possible value for x. Because there are N variables
each with K states, there are K N values for x and so evaluation and storage of the
joint distribution, as well as marginalization to obtain p(xn ), all involve storage and
computation that scale exponentially with the length N of the chain.
We can, however, obtain a much more efficient algorithm by exploiting the conditional independence properties of the graphical model. If we substitute the factorized expression (8.49) for the joint distribution into (8.50), then we can rearrange the
order of the summations and the multiplications to allow the required marginal to be
evaluated much more efficiently. Consider for instance the summation over xN . The
potential ψN −1,N (xN −1 , xN ) is the only one that depends on xN , and so we can
perform the summation
ψN −1,N (xN −1 , xN )

(8.51)

xN

first to give a function of xN −1 . We can then use this to perform the summation
over xN −1 , which will involve only this new function together with the potential
ψN −2,N −1 (xN −2 , xN −1 ), because this is the only other place that xN −1 appears.
Similarly, the summation over x1 involves only the potential ψ1,2 (x1 , x2 ) and so
can be performed separately to give a function of x2 , and so on. Because each
summation effectively removes a variable from the distribution, this can be viewed
as the removal of a node from the graph.
If we group the potentials and summations together in this way, we can express

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

396

8. GRAPHICAL MODELS
the desired marginal in the form
1
p(xn ) =
Z







xn−1

ψn−1,n (xn−1 , xn ) · · ·

x1

x2

µα (xn )

xn+1

ψn,n+1 (xn , xn+1 ) · · ·

ψ1,2 (x1 , x2 )

ψ2,3 (x2 , x3 )

xN



ψN −1,N (xN −1 , xN ) · · ·  .



···

(8.52)

µβ (xn )

The reader is encouraged to study this re-ordering carefully as the underlying idea
forms the basis for the later discussion of the general sum-product algorithm. Here
the key concept that we are exploiting is that multiplication is distributive over addition, so that
ab + ac = a(b + c)
(8.53)
in which the left-hand side involves three arithmetic operations whereas the righthand side reduces this to two operations.
Let us work out the computational cost of evaluating the required marginal using
this re-ordered expression. We have to perform N − 1 summations each of which is
over K states and each of which involves a function of two variables. For instance,
the summation over x1 involves only the function ψ1,2 (x1 , x2 ), which is a table of
K × K numbers. We have to sum this table over x1 for each value of x2 and so this
has O(K 2 ) cost. The resulting vector of K numbers is multiplied by the matrix of
numbers ψ2,3 (x2 , x3 ) and so is again O(K 2 ). Because there are N − 1 summations
and multiplications of this kind, the total cost of evaluating the marginal p(xn ) is
O(N K 2 ). This is linear in the length of the chain, in contrast to the exponential cost
of a naive approach. We have therefore been able to exploit the many conditional
independence properties of this simple graph in order to obtain an efficient calculation. If the graph had been fully connected, there would have been no conditional
independence properties, and we would have been forced to work directly with the
full joint distribution.
We now give a powerful interpretation of this calculation in terms of the passing
of local messages around on the graph. From (8.52) we see that the expression for the
marginal p(xn ) decomposes into the product of two factors times the normalization
constant
1
p(xn ) = µα (xn )µβ (xn ).
(8.54)
Z
We shall interpret µα (xn ) as a message passed forwards along the chain from node
xn−1 to node xn . Similarly, µβ (xn ) can be viewed as a message passed backwards

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.4. Inference in Graphical Models
Figure 8.38 The marginal distribution
p(xn ) for a node xn along the chain is obtained by multiplying the two messages
µα (xn ) and µβ (xn ), and then normalizing. These messages can themselves
be evaluated recursively by passing messages from both ends of the chain towards node xn .

µα (xn−1 )
x1

µβ (xn )

µα (xn )

xn−1

xn

397

µβ (xn+1 )

xn+1

xN

along the chain to node xn from node xn+1 . Note that each of the messages comprises a set of K values, one for each choice of xn , and so the product of two messages should be interpreted as the point-wise multiplication of the elements of the
two messages to give another set of K values.
The message µα (xn ) can be evaluated recursively because


µα (xn ) =

xn−1

=

ψn−1,n (xn−1 , xn ) 

xn−2

···

ψn−1,n (xn−1 , xn )µα (xn−1 ).

(8.55)

xn−1

We therefore first evaluate
ψ1,2 (x1 , x2 )

µα (x2 ) =

(8.56)

x1

and then apply (8.55) repeatedly until we reach the desired node. Note carefully the
structure of the message passing equation. The outgoing message µα (xn ) in (8.55)
is obtained by multiplying the incoming message µα (xn−1 ) by the local potential
involving the node variable and the outgoing variable and then summing over the
node variable.
Similarly, the message µβ (xn ) can be evaluated recursively by starting with
node xN and using


µβ (xn ) =

xn+1

ψn+1,n (xn+1 , xn ) 

xn+2

···

ψn+1,n (xn+1 , xn )µβ (xn+1 ).

=

(8.57)

xn+1

This recursive message passing is illustrated in Figure 8.38.
The normalization
constant Z is easily evaluated by summing the right-hand side of (8.54) over all
states of xn , an operation that requires only O(K) computation.
Graphs of the form shown in Figure 8.38 are called Markov chains, and the
corresponding message passing equations represent an example of the ChapmanKolmogorov equations for Markov processes (Papoulis, 1984).

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

398

8. GRAPHICAL MODELS

Exercise 8.15

Chapter 9

Now suppose we wish to evaluate the marginals p(xn ) for every node n ∈
{1, . . . , N } in the chain. Simply applying the above procedure separately for each
node will have computational cost that is O(N 2 M 2 ). However, such an approach
would be very wasteful of computation. For instance, to find p(x1 ) we need to propagate a message µβ (·) from node xN back to node x2 . Similarly, to evaluate p(x2 )
we need to propagate a messages µβ (·) from node xN back to node x3 . This will
involve much duplicated computation because most of the messages will be identical
in the two cases.
Suppose instead we first launch a message µβ (xN −1 ) starting from node xN
and propagate corresponding messages all the way back to node x1 , and suppose we
similarly launch a message µα (x2 ) starting from node x1 and propagate the corresponding messages all the way forward to node xN . Provided we store all of the
intermediate messages along the way, then any node can evaluate its marginal simply by applying (8.54). The computational cost is only twice that for finding the
marginal of a single node, rather than N times as much. Observe that a message
has passed once in each direction across each link in the graph. Note also that the
normalization constant Z need be evaluated only once, using any convenient node.
If some of the nodes in the graph are observed, then the corresponding variables
are simply clamped to their observed values and there is no summation. To see
this, note that the effect of clamping a variable xn to an observed value xn can
be expressed by multiplying the joint distribution by (one or more copies of) an
additional function I(xn , xn ), which takes the value 1 when xn = xn and the value
0 otherwise. One such function can then be absorbed into each of the potentials that
contain xn . Summations over xn then contain only one term in which xn = xn .
Now suppose we wish to calculate the joint distribution p(xn−1 , xn ) for two
neighbouring nodes on the chain. This is similar to the evaluation of the marginal
for a single node, except that there are now two variables that are not summed out.
A few moments thought will show that the required joint distribution can be written
in the form
1
p(xn−1 , xn ) = µα (xn−1 )ψn−1,n (xn−1 , xn )µβ (xn ).
(8.58)
Z
Thus we can obtain the joint distributions over all of the sets of variables in each
of the potentials directly once we have completed the message passing required to
obtain the marginals.
This is a useful result because in practice we may wish to use parametric forms
for the clique potentials, or equivalently for the conditional distributions if we started
from a directed graph. In order to learn the parameters of these potentials in situations where not all of the variables are observed, we can employ the EM algorithm,
and it turns out that the local joint distributions of the cliques, conditioned on any
observed data, is precisely what is needed in the E step. We shall consider some
examples of this in detail in Chapter 13.

8.4.2 Trees
We have seen that exact inference on a graph comprising a chain of nodes can be
performed efficiently in time that is linear in the number of nodes, using an algorithm

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

399

8.4. Inference in Graphical Models
Figure 8.39 Examples of treestructured graphs, showing (a) an
undirected tree, (b) a directed tree,
and (c) a directed polytree.

(a)

Exercise 8.18

(b)

(c)

that can be interpreted in terms of messages passed along the chain. More generally,
inference can be performed efficiently using local message passing on a broader
class of graphs called trees. In particular, we shall shortly generalize the message
passing formalism derived above for chains to give the sum-product algorithm, which
provides an efficient framework for exact inference in tree-structured graphs.
In the case of an undirected graph, a tree is defined as a graph in which there
is one, and only one, path between any pair of nodes. Such graphs therefore do not
have loops. In the case of directed graphs, a tree is defined such that there is a single
node, called the root, which has no parents, and all other nodes have one parent. If
we convert a directed tree into an undirected graph, we see that the moralization step
will not add any links as all nodes have at most one parent, and as a consequence the
corresponding moralized graph will be an undirected tree. Examples of undirected
and directed trees are shown in Figure 8.39(a) and 8.39(b). Note that a distribution
represented as a directed tree can easily be converted into one represented by an
undirected tree, and vice versa.
If there are nodes in a directed graph that have more than one parent, but there is
still only one path (ignoring the direction of the arrows) between any two nodes, then
the graph is a called a polytree, as illustrated in Figure 8.39(c). Such a graph will
have more than one node with the property of having no parents, and furthermore,
the corresponding moralized undirected graph will have loops.

8.4.3 Factor graphs
The sum-product algorithm that we derive in the next section is applicable to
undirected and directed trees and to polytrees. It can be cast in a particularly simple
and general form if we first introduce a new graphical construction called a factor
graph (Frey, 1998; Kschischnang et al., 2001).
Both directed and undirected graphs allow a global function of several variables to be expressed as a product of factors over subsets of those variables. Factor
graphs make this decomposition explicit by introducing additional nodes for the factors themselves in addition to the nodes representing the variables. They also allow
us to be more explicit about the details of the factorization, as we shall see.
Let us write the joint distribution over a set of variables in the form of a product
of factors
p(x) =
fs (xs )
(8.59)
s

where xs denotes a subset of the variables. For convenience, we shall denote the

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

400

8. GRAPHICAL MODELS
x1

Figure 8.40 Example of a factor graph, which corresponds
to the factorization (8.60).

x2

fa

fb

x3

fc

fd

individual variables by xi , however, as in earlier discussions, these can comprise
groups of variables (such as vectors or matrices). Each factor fs is a function of a
corresponding set of variables xs .
Directed graphs, whose factorization is defined by (8.5), represent special cases
of (8.59) in which the factors fs (xs ) are local conditional distributions. Similarly,
undirected graphs, given by (8.39), are a special case in which the factors are potential functions over the maximal cliques (the normalizing coefficient 1/Z can be
viewed as a factor defined over the empty set of variables).
In a factor graph, there is a node (depicted as usual by a circle) for every variable
in the distribution, as was the case for directed and undirected graphs. There are also
additional nodes (depicted by small squares) for each factor fs (xs ) in the joint distribution. Finally, there are undirected links connecting each factor node to all of the
variables nodes on which that factor depends. Consider, for example, a distribution
that is expressed in terms of the factorization
p(x) = fa (x1 , x2 )fb (x1 , x2 )fc (x2 , x3 )fd (x3 ).

(8.60)

This can be expressed by the factor graph shown in Figure 8.40. Note that there are
two factors fa (x1 , x2 ) and fb (x1 , x2 ) that are defined over the same set of variables.
In an undirected graph, the product of two such factors would simply be lumped
together into the same clique potential. Similarly, fc (x2 , x3 ) and fd (x3 ) could be
combined into a single potential over x2 and x3 . The factor graph, however, keeps
such factors explicit and so is able to convey more detailed information about the
underlying factorization.
x1

x2

x1

x2

x1

x2
fa

f

fb
x3
(a)

x3
(b)

x3
(c)

Figure 8.41 (a) An undirected graph with a single clique potential ψ(x1 , x2 , x3 ). (b) A factor graph with factor
f (x1 , x2 , x3 ) = ψ(x1 , x2 , x3 ) representing the same distribution as the undirected graph. (c) A different factor
graph representing the same distribution, whose factors satisfy fa (x1 , x2 , x3 )fb (x1 , x2 ) = ψ(x1 , x2 , x3 ).

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

401

8.4. Inference in Graphical Models
x1

x2

x1

x2

x1

x2
fc

f
fa
x3
(a)

fb

x3
(b)

x3
(c)

Figure 8.42 (a) A directed graph with the factorization p(x1 )p(x2 )p(x3 |x1 , x2 ). (b) A factor graph representing
the same distribution as the directed graph, whose factor satisfies f (x1 , x2 , x3 ) = p(x1 )p(x2 )p(x3 |x1 , x2 ). (c)
A different factor graph representing the same distribution with factors fa (x1 ) = p(x1 ), fb (x2 ) = p(x2 ) and
fc (x1 , x2 , x3 ) = p(x3 |x1 , x2 ).

Factor graphs are said to be bipartite because they consist of two distinct kinds
of nodes, and all links go between nodes of opposite type. In general, factor graphs
can therefore always be drawn as two rows of nodes (variable nodes at the top and
factor nodes at the bottom) with links between the rows, as shown in the example in
Figure 8.40. In some situations, however, other ways of laying out the graph may
be more intuitive, for example when the factor graph is derived from a directed or
undirected graph, as we shall see.
If we are given a distribution that is expressed in terms of an undirected graph,
then we can readily convert it to a factor graph. To do this, we create variable nodes
corresponding to the nodes in the original undirected graph, and then create additional factor nodes corresponding to the maximal cliques xs . The factors fs (xs ) are
then set equal to the clique potentials. Note that there may be several different factor
graphs that correspond to the same undirected graph. These concepts are illustrated
in Figure 8.41.
Similarly, to convert a directed graph to a factor graph, we simply create variable
nodes in the factor graph corresponding to the nodes of the directed graph, and then
create factor nodes corresponding to the conditional distributions, and then finally
add the appropriate links. Again, there can be multiple factor graphs all of which
correspond to the same directed graph. The conversion of a directed graph to a
factor graph is illustrated in Figure 8.42.
We have already noted the importance of tree-structured graphs for performing
efficient inference. If we take a directed or undirected tree and convert it into a factor
graph, then the result will again be a tree (in other words, the factor graph will have
no loops, and there will be one and only one path connecting any two nodes). In
the case of a directed polytree, conversion to an undirected graph results in loops
due to the moralization step, whereas conversion to a factor graph again results in a
tree, as illustrated in Figure 8.43. In fact, local cycles in a directed graph due to
links connecting parents of a node can be removed on conversion to a factor graph
by defining the appropriate factor function, as shown in Figure 8.44.
We have seen that multiple different factor graphs can represent the same directed or undirected graph. This allows factor graphs to be more specific about the

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

402

8. GRAPHICAL MODELS

(a)

(b)

(c)

Figure 8.43 (a) A directed polytree. (b) The result of converting the polytree into an undirected graph showing
the creation of loops. (c) The result of converting the polytree into a factor graph, which retains the tree structure.

precise form of the factorization. Figure 8.45 shows an example of a fully connected
undirected graph along with two different factor graphs.
In (b), the joint distribution is given by a general form p(x) = f (x1 , x2 , x3 ), whereas in (c), it is given
by the more specific factorization p(x) = fa (x1 , x2 )fb (x1 , x3 )fc (x2 , x3 ). It should
be emphasized that the factorization in (c) does not correspond to any conditional
independence properties.

8.4.4 The sum-product algorithm

Section 13.3

We shall now make use of the factor graph framework to derive a powerful class
of efficient, exact inference algorithms that are applicable to tree-structured graphs.
Here we shall focus on the problem of evaluating local marginals over nodes or
subsets of nodes, which will lead us to the sum-product algorithm. Later we shall
modify the technique to allow the most probable state to be found, giving rise to the
max-sum algorithm.
Also we shall suppose that all of the variables in the model are discrete, and
so marginalization corresponds to performing sums. The framework, however, is
equally applicable to linear-Gaussian models in which case marginalization involves
integration, and we shall consider an example of this in detail when we discuss linear
dynamical systems.

Figure 8.44 (a) A fragment of a directed graph having a local cycle. (b) Conversion
to a fragment of a factor
graph having a tree structure, in which f (x1 , x2 , x3 ) =
p(x1 )p(x2 |x1 )p(x3 |x1 , x2 ).

x1

x2

x1

x2

f (x1 , x2 , x3 )
x3
(a)

x3
(b)

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

403

8.4. Inference in Graphical Models
x1

x2

x1

x2

x1

f (x1 , x2 , x3 )
x3
(a)

x2

fa

fb

fc

x3

x3
(c)

(b)

Figure 8.45 (a) A fully connected undirected graph. (b) and (c) Two factor graphs each of which corresponds
to the undirected graph in (a).

There is an algorithm for exact inference on directed graphs without loops known
as belief propagation (Pearl, 1988; Lauritzen and Spiegelhalter, 1988), and is equivalent to a special case of the sum-product algorithm. Here we shall consider only the
sum-product algorithm because it is simpler to derive and to apply, as well as being
more general.
We shall assume that the original graph is an undirected tree or a directed tree or
polytree, so that the corresponding factor graph has a tree structure. We first convert
the original graph into a factor graph so that we can deal with both directed and
undirected models using the same framework. Our goal is to exploit the structure of
the graph to achieve two things: (i) to obtain an efficient, exact inference algorithm
for finding marginals; (ii) in situations where several marginals are required to allow
computations to be shared efficiently.
We begin by considering the problem of finding the marginal p(x) for particular variable node x. For the moment, we shall suppose that all of the variables
are hidden. Later we shall see how to modify the algorithm to incorporate evidence
corresponding to observed variables. By definition, the marginal is obtained by summing the joint distribution over all variables except x so that
p(x) =

p(x)

(8.61)

x\x

where x \ x denotes the set of variables in x with variable x omitted. The idea is
to substitute for p(x) using the factor graph expression (8.59) and then interchange
summations and products in order to obtain an efficient algorithm. Consider the
fragment of graph shown in Figure 8.46 in which we see that the tree structure of
the graph allows us to partition the factors in the joint distribution into groups, with
one group associated with each of the factor nodes that is a neighbour of the variable
node x. We see that the joint distribution can be written as a product of the form
p(x) =

Fs (x, Xs )

(8.62)

s∈ne(x)

ne(x) denotes the set of factor nodes that are neighbours of x, and Xs denotes the
set of all variables in the subtree connected to the variable node x via the factor node

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8. GRAPHICAL MODELS
Figure 8.46 A fragment of a factor graph illustrating the
evaluation of the marginal p(x).

µfs →x (x)

Fs (x, Xs )

404

fs

x

fs , and Fs (x, Xs ) represents the product of all the factors in the group associated
with factor fs .
Substituting (8.62) into (8.61) and interchanging the sums and products, we obtain
p(x) =

Fs (x, Xs )
s∈ne(x)

=

Xs

µfs →x (x).

(8.63)

s∈ne(x)

Here we have introduced a set of functions µfs →x (x), defined by
µfs →x (x) ≡

Fs (x, Xs )

(8.64)

Xs

which can be viewed as messages from the factor nodes fs to the variable node x.
We see that the required marginal p(x) is given by the product of all the incoming
messages arriving at node x.
In order to evaluate these messages, we again turn to Figure 8.46 and note that
each factor Fs (x, Xs ) is described by a factor (sub-)graph and so can itself be factorized. In particular, we can write
Fs (x, Xs ) = fs (x, x1 , . . . , xM )G1 (x1 , Xs1 ) . . . GM (xM , XsM )

(8.65)

where, for convenience, we have denoted the variables associated with factor fx , in
addition to x, by x1 , . . . , xM . This factorization is illustrated in Figure 8.47. Note
that the set of variables {x, x1 , . . . , xM } is the set of variables on which the factor
fs depends, and so it can also be denoted xs , using the notation of (8.59).
Substituting (8.65) into (8.64) we obtain
µfs →x (x) =

...
x1

=

fs (x, x1 , . . . , xM )
xM

...
x1

Gm (xm , Xsm )
m∈ne(fs )\x

fs (x, x1 , . . . , xM )
xM

Xxm

µxm →fs (xm )

(8.66)

m∈ne(fs )\x

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.4. Inference in Graphical Models

405

xM

Figure 8.47 Illustration of the factorization of the subgraph associated with factor node fs .

µxM →fs (xM )
fs
µfs →x (x)

x

xm
Gm (xm , Xsm )

where ne(fs ) denotes the set of variable nodes that are neighbours of the factor node
fs , and ne(fs ) \ x denotes the same set but with node x removed. Here we have
defined the following messages from variable nodes to factor nodes
µxm→fs (xm ) ≡

Gm (xm , Xsm ).

(8.67)

Xsm

We have therefore introduced two distinct kinds of message, those that go from factor
nodes to variable nodes denoted µf →x (x), and those that go from variable nodes to
factor nodes denoted µx→f (x). In each case, we see that messages passed along a
link are always a function of the variable associated with the variable node that link
connects to.
The result (8.66) says that to evaluate the message sent by a factor node to a variable node along the link connecting them, take the product of the incoming messages
along all other links coming into the factor node, multiply by the factor associated
with that node, and then marginalize over all of the variables associated with the
incoming messages. This is illustrated in Figure 8.47. It is important to note that
a factor node can send a message to a variable node once it has received incoming
messages from all other neighbouring variable nodes.
Finally, we derive an expression for evaluating the messages from variable nodes
to factor nodes, again by making use of the (sub-)graph factorization. From Figure 8.48, we see that term Gm (xm , Xsm ) associated with node xm is given by a
product of terms Fl (xm , Xml ) each associated with one of the factor nodes fl that is
linked to node xm (excluding node fs ), so that
Fl (xm , Xml )

Gm (xm , Xsm ) =

(8.68)

l∈ne(xm )\fs

where the product is taken over all neighbours of node xm except for node fs .
Note that each of the factors Fl (xm , Xml ) represents a subtree of the original graph
of precisely the same kind as introduced in (8.62). Substituting (8.68) into (8.67),

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

406

8. GRAPHICAL MODELS
Figure 8.48 Illustration of the evaluation of the message sent by a
variable node to an adjacent factor node.

fL

fs

xm
fl
Fl (xm , Xml )

we then obtain
µxm →fs (xm ) =

Fl (xm , Xml )
l∈ne(xm )\fs

Xml

µfl →xm (xm )

=

(8.69)

l∈ne(xm )\fs

where we have used the definition (8.64) of the messages passed from factor nodes to
variable nodes. Thus to evaluate the message sent by a variable node to an adjacent
factor node along the connecting link, we simply take the product of the incoming
messages along all of the other links. Note that any variable node that has only
two neighbours performs no computation but simply passes messages through unchanged. Also, we note that a variable node can send a message to a factor node
once it has received incoming messages from all other neighbouring factor nodes.
Recall that our goal is to calculate the marginal for variable node x, and that this
marginal is given by the product of incoming messages along all of the links arriving
at that node. Each of these messages can be computed recursively in terms of other
messages. In order to start this recursion, we can view the node x as the root of the
tree and begin at the leaf nodes. From the definition (8.69), we see that if a leaf node
is a variable node, then the message that it sends along its one and only link is given
by
µx→f (x) = 1
(8.70)
as illustrated in Figure 8.49(a). Similarly, if the leaf node is a factor node, we see
from (8.66) that the message sent should take the form
µf →x (x) = f (x)
Figure 8.49 The sum-product algorithm
begins with messages sent
by the leaf nodes, which depend on whether the leaf
node is (a) a variable node,
or (b) a factor node.

µf →x (x) = f (x)

µx→f (x) = 1
x

f
(a)

(8.71)

x

f
(b)

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.4. Inference in Graphical Models

Exercise 8.20

407

as illustrated in Figure 8.49(b).
At this point, it is worth pausing to summarize the particular version of the sumproduct algorithm obtained so far for evaluating the marginal p(x). We start by
viewing the variable node x as the root of the factor graph and initiating messages
at the leaves of the graph using (8.70) and (8.71). The message passing steps (8.66)
and (8.69) are then applied recursively until messages have been propagated along
every link, and the root node has received messages from all of its neighbours. Each
node can send a message towards the root once it has received messages from all
of its other neighbours. Once the root node has received messages from all of its
neighbours, the required marginal can be evaluated using (8.63). We shall illustrate
this process shortly.
To see that each node will always receive enough messages to be able to send out
a message, we can use a simple inductive argument as follows. Clearly, for a graph
comprising a variable root node connected directly to several factor leaf nodes, the
algorithm trivially involves sending messages of the form (8.71) directly from the
leaves to the root. Now imagine building up a general graph by adding nodes one at
a time, and suppose that for some particular graph we have a valid algorithm. When
one more (variable or factor) node is added, it can be connected only by a single
link because the overall graph must remain a tree, and so the new node will be a leaf
node. It therefore sends a message to the node to which it is linked, which in turn
will therefore receive all the messages it requires in order to send its own message
towards the root, and so again we have a valid algorithm, thereby completing the
proof.
Now suppose we wish to find the marginals for every variable node in the graph.
This could be done by simply running the above algorithm afresh for each such node.
However, this would be very wasteful as many of the required computations would
be repeated. We can obtain a much more efficient procedure by ‘overlaying’ these
multiple message passing algorithms to obtain the general sum-product algorithm
as follows. Arbitrarily pick any (variable or factor) node and designate it as the
root. Propagate messages from the leaves to the root as before. At this point, the
root node will have received messages from all of its neighbours. It can therefore
send out messages to all of its neighbours. These in turn will then have received
messages from all of their neighbours and so can send out messages along the links
going away from the root, and so on. In this way, messages are passed outwards
from the root all the way to the leaves. By now, a message will have passed in
both directions across every link in the graph, and every node will have received
a message from all of its neighbours. Again a simple inductive argument can be
used to verify the validity of this message passing protocol. Because every variable
node will have received messages from all of its neighbours, we can readily calculate
the marginal distribution for every variable in the graph. The number of messages
that have to be computed is given by twice the number of links in the graph and
so involves only twice the computation involved in finding a single marginal. By
comparison, if we had run the sum-product algorithm separately for each node, the
amount of computation would grow quadratically with the size of the graph. Note
that this algorithm is in fact independent of which node was designated as the root,

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

408

8. GRAPHICAL MODELS
Figure 8.50 The sum-product algorithm can be viewed
purely in terms of messages sent out by factor
nodes to other factor nodes. In this example,
the outgoing message shown by the blue arrow
is obtained by taking the product of all the incoming messages shown by green arrows, multiplying by the factor fs , and marginalizing over
the variables x1 and x2 .

Exercise 8.21

x1
x3
x2

fs

and indeed the notion of one node having a special status was introduced only as a
convenient way to explain the message passing protocol.
Next suppose we wish to find the marginal distributions p(xs ) associated with
the sets of variables belonging to each of the factors. By a similar argument to that
used above, it is easy to see that the marginal associated with a factor is given by the
product of messages arriving at the factor node and the local factor at that node
p(xs ) = fs (xs )

µxi →fs (xi )

(8.72)

i∈ne(fs )

in complete analogy with the marginals at the variable nodes. If the factors are
parameterized functions and we wish to learn the values of the parameters using
the EM algorithm, then these marginals are precisely the quantities we will need to
calculate in the E step, as we shall see in detail when we discuss the hidden Markov
model in Chapter 13.
The message sent by a variable node to a factor node, as we have seen, is simply
the product of the incoming messages on other links. We can if we wish view the
sum-product algorithm in a slightly different form by eliminating messages from
variable nodes to factor nodes and simply considering messages that are sent out by
factor nodes. This is most easily seen by considering the example in Figure 8.50.
So far, we have rather neglected the issue of normalization. If the factor graph
was derived from a directed graph, then the joint distribution is already correctly normalized, and so the marginals obtained by the sum-product algorithm will similarly
be normalized correctly. However, if we started from an undirected graph, then in
general there will be an unknown normalization coefficient 1/Z. As with the simple
chain example of Figure 8.38, this is easily handled by working with an unnormalized version p(x) of the joint distribution, where p(x) = p(x)/Z. We first run the
sum-product algorithm to find the corresponding unnormalized marginals p(xi ). The
coefficient 1/Z is then easily obtained by normalizing any one of these marginals,
and this is computationally efficient because the normalization is done over a single
variable rather than over the entire set of variables as would be required to normalize
p(x) directly.
At this point, it may be helpful to consider a simple example to illustrate the
operation of the sum-product algorithm. Figure 8.51 shows a simple 4-node factor

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.4. Inference in Graphical Models
x1

Figure 8.51 A simple factor graph used to illustrate the
sum-product algorithm.

x2

409
x3

fa

fb
fc

x4

graph whose unnormalized joint distribution is given by
p(x) = fa (x1 , x2 )fb (x2 , x3 )fc (x2 , x4 ).

(8.73)

In order to apply the sum-product algorithm to this graph, let us designate node x3
as the root, in which case there are two leaf nodes x1 and x4 . Starting with the leaf
nodes, we then have the following sequence of six messages
µx1 →fa (x1 ) = 1

(8.74)
fa (x1 , x2 )

µfa →x2 (x2 ) =

(8.75)

x1

µx4 →fc (x4 ) = 1

(8.76)

µfc →x2 (x2 ) =

fc (x2 , x4 )

(8.77)

x4

µx2 →fb (x2 ) = µfa →x2 (x2 )µfc →x2 (x2 )

(8.78)

µfb →x3 (x3 ) =

(8.79)

fb (x2 , x3 )µx2 →fb .
x2

The direction of flow of these messages is illustrated in Figure 8.52. Once this
message propagation is complete, we can then propagate messages from the root
node out to the leaf nodes, and these are given by
µx3 →fb (x3 ) = 1

(8.80)
fb (x2 , x3 )

µfb →x2 (x2 ) =

(8.81)

x3

µx2 →fa (x2 ) = µfb →x2 (x2 )µfc →x2 (x2 )

(8.82)

µfa →x1 (x1 ) =

(8.83)

fa (x1 , x2 )µx2 →fa (x2 )
x2

µx2 →fc (x2 ) = µfa →x2 (x2 )µfb →x2 (x2 )

(8.84)

µfc →x4 (x4 ) =

(8.85)

fc (x2 , x4 )µx2 →fc (x2 ).
x2

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

410

8. GRAPHICAL MODELS
x1

x2

x3

x1

x2

x4

x4

(a)

x3

(b)

Figure 8.52 Flow of messages for the sum-product algorithm applied to the example graph in Figure 8.51. (a)
From the leaf nodes x1 and x4 towards the root node x3 . (b) From the root node towards the leaf nodes.

One message has now passed in each direction across each link, and we can now
evaluate the marginals. As a simple check, let us verify that the marginal p(x2 ) is
given by the correct expression. Using (8.63) and substituting for the messages using
the above results, we have
p(x2 ) = µfa →x2 (x2 )µfb →x2 (x2 )µfc →x2 (x2 )
=

fa (x1 , x2 )
x1

fb (x2 , x3 )
x3

fc (x2 , x4 )
x4

fa (x1 , x2 )fb (x2 , x3 )fc (x2 , x4 )

=
x1

x2

x4

x1

x3

x4

p(x)

=

(8.86)

as required.
So far, we have assumed that all of the variables in the graph are hidden. In most
practical applications, a subset of the variables will be observed, and we wish to calculate posterior distributions conditioned on these observations. Observed nodes are
easily handled within the sum-product algorithm as follows. Suppose we partition x
into hidden variables h and observed variables v, and that the observed value of v
is denoted v. Then we simply multiply the joint distribution p(x) by i I(vi , vi ),
where I(v, v) = 1 if v = v and I(v, v) = 0 otherwise. This product corresponds
to p(h, v = v) and hence is an unnormalized version of p(h|v = v). By running the sum-product algorithm, we can efficiently calculate the posterior marginals
p(hi |v = v) up to a normalization coefficient whose value can be found efficiently
using a local computation. Any summations over variables in v then collapse into a
single term.
We have assumed throughout this section that we are dealing with discrete variables. However, there is nothing specific to discrete variables either in the graphical
framework or in the probabilistic construction of the sum-product algorithm. For

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.4. Inference in Graphical Models
Table 8.1 Example of a joint distribution over two binary variables for
which the maximum of the joint distribution occurs for different variable values compared to the maxima of the two
marginals.

Section 13.3

y=0
y=1

x=0
0.3
0.3

411
x=1
0.4
0.0

continuous variables the summations are simply replaced by integrations. We shall
give an example of the sum-product algorithm applied to a graph of linear-Gaussian
variables when we consider linear dynamical systems.

8.4.5 The max-sum algorithm
The sum-product algorithm allows us to take a joint distribution p(x) expressed
as a factor graph and efficiently find marginals over the component variables. Two
other common tasks are to find a setting of the variables that has the largest probability and to find the value of that probability. These can be addressed through a
closely related algorithm called max-sum, which can be viewed as an application of
dynamic programming in the context of graphical models (Cormen et al., 2001).
A simple approach to finding latent variable values having high probability
would be to run the sum-product algorithm to obtain the marginals p(xi ) for every
variable, and then, for each marginal in turn, to find the value xi that maximizes
that marginal. However, this would give the set of values that are individually the
most probable. In practice, we typically wish to find the set of values that jointly
have the largest probability, in other words the vector xmax that maximizes the joint
distribution, so that
xmax = arg max p(x)
(8.87)
x

for which the corresponding value of the joint probability will be given by
p(xmax ) = max p(x).

(8.88)

x

Exercise 8.27

In general, xmax is not the same as the set of xi values, as we can easily show using
a simple example. Consider the joint distribution p(x, y) over two binary variables
x, y ∈ {0, 1} given in Table 8.1. The joint distribution is maximized by setting x =
1 and y = 0, corresponding the value 0.4. However, the marginal for p(x), obtained
by summing over both values of y, is given by p(x = 0) = 0.6 and p(x = 1) = 0.4,
and similarly the marginal for y is given by p(y = 0) = 0.7 and p(y = 1) = 0.3,
and so the marginals are maximized by x = 0 and y = 0, which corresponds to a
value of 0.3 for the joint distribution. In fact, it is not difficult to construct examples
for which the set of individually most probable values has probability zero under the
joint distribution.
We therefore seek an efficient algorithm for finding the value of x that maximizes the joint distribution p(x) and that will allow us to obtain the value of the
joint distribution at its maximum. To address the second of these problems, we shall
simply write out the max operator in terms of its components
max p(x) = max . . . max p(x)
x

x1

xM

(8.89)

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

412

8. GRAPHICAL MODELS
where M is the total number of variables, and then substitute for p(x) using its
expansion in terms of a product of factors. In deriving the sum-product algorithm,
we made use of the distributive law (8.53) for multiplication. Here we make use of
the analogous law for the max operator
max(ab, ac) = a max(b, c)

(8.90)

which holds if a 0 (as will always be the case for the factors in a graphical model).
This allows us to exchange products with maximizations.
Consider first the simple example of a chain of nodes described by (8.49). The
evaluation of the probability maximum can be written as
max p(x) =
x

=

1
max · · · max [ψ1,2 (x1 , x2 ) · · · ψN −1,N (xN −1 , xN )]
xN
Z x1

1
max ψ1,2 (x1 , x2 ) · · · max ψN −1,N (xN −1 , xN )
xN
Z x1

.

As with the calculation of marginals, we see that exchanging the max and product
operators results in a much more efficient computation, and one that is easily interpreted in terms of messages passed from node xN backwards along the chain to node
x1 .
We can readily generalize this result to arbitrary tree-structured factor graphs
by substituting the expression (8.59) for the factor graph expansion into (8.89) and
again exchanging maximizations with products. The structure of this calculation is
identical to that of the sum-product algorithm, and so we can simply translate those
results into the present context. In particular, suppose that we designate a particular
variable node as the ‘root’ of the graph. Then we start a set of messages propagating
inwards from the leaves of the tree towards the root, with each node sending its
message towards the root once it has received all incoming messages from its other
neighbours. The final maximization is performed over the product of all messages
arriving at the root node, and gives the maximum value for p(x). This could be called
the max-product algorithm and is identical to the sum-product algorithm except that
summations are replaced by maximizations. Note that at this stage, messages have
been sent from leaves to the root, but not in the other direction.
In practice, products of many small probabilities can lead to numerical underflow problems, and so it is convenient to work with the logarithm of the joint distribution. The logarithm is a monotonic function, so that if a > b then ln a > ln b, and
hence the max operator and the logarithm function can be interchanged, so that
ln max p(x) = max ln p(x).
x

(8.91)

x

The distributive property is preserved because
max(a + b, a + c) = a + max(b, c).

(8.92)

Thus taking the logarithm simply has the effect of replacing the products in the
max-product algorithm with sums, and so we obtain the max-sum algorithm. From

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.4. Inference in Graphical Models

413

the results (8.66) and (8.69) derived earlier for the sum-product algorithm, we can
readily write down the max-sum algorithm in terms of message passing simply by
replacing ‘sum’ with ‘max’ and replacing products with sums of logarithms to give


µf →x (x) =

µx→f (x) =

max ln f (x, x1 , . . . , xM ) +

x1 ,...,xM

µxm →f (xm ) (8.93)

m∈ne(fs )\x

µfl →x (x).

(8.94)

l∈ne(x)\f

The initial messages sent by the leaf nodes are obtained by analogy with (8.70) and
(8.71) and are given by
µx→f (x) = 0
µf →x (x) = ln f (x)

(8.95)
(8.96)

while at the root node the maximum probability can then be computed, by analogy
with (8.63), using


pmax = max 
x

s∈ne(x)

µfs →x (x) .

(8.97)

So far, we have seen how to find the maximum of the joint distribution by propagating messages from the leaves to an arbitrarily chosen root node. The result will
be the same irrespective of which node is chosen as the root. Now we turn to the
second problem of finding the configuration of the variables for which the joint distribution attains this maximum value. So far, we have sent messages from the leaves
to the root. The process of evaluating (8.97) will also give the value xmax for the
most probable value of the root node variable, defined by


xmax = arg max 
x

s∈ne(x)

µfs →x (x) .

(8.98)

At this point, we might be tempted simply to continue with the message passing algorithm and send messages from the root back out to the leaves, using (8.93) and
(8.94), then apply (8.98) to all of the remaining variable nodes. However, because
we are now maximizing rather than summing, it is possible that there may be multiple configurations of x all of which give rise to the maximum value for p(x). In
such cases, this strategy can fail because it is possible for the individual variable
values obtained by maximizing the product of messages at each node to belong to
different maximizing configurations, giving an overall configuration that no longer
corresponds to a maximum.
The problem can be resolved by adopting a rather different kind of message
passing from the root node to the leaves. To see how this works, let us return once
again to the simple chain example of N variables x1 , . . . , xN each having K states,

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

414

8. GRAPHICAL MODELS

Figure 8.53 A lattice, or trellis, diagram showing explicitly the K possible states (one per row
of the diagram) for each of the variables xn in the k = 1
chain model. In this illustration K = 3. The arrow shows the direction of message passing in the
max-product algorithm. For every state k of each
variable xn (corresponding to column n of the diagram) the function φ(xn ) defines a unique state at
the previous variable, indicated by the black lines. k = 2
The two paths through the lattice correspond to
configurations that give the global maximum of the
joint probability distribution, and either of these
can be found by tracing back along the black lines
in the opposite direction to the arrow.

k=3
n−2

n−1

n

n+1

corresponding to the graph shown in Figure 8.38. Suppose we take node xN to be
the root node. Then in the first phase, we propagate messages from the leaf node x1
to the root node using
µxn →fn,n+1 (xn ) = µfn−1,n →xn (xn )
µfn−1,n →xn (xn ) = max ln fn−1,n (xn−1 , xn ) + µxn−1 →f n−1,n (xn )
xn−1

which follow from applying (8.94) and (8.93) to this particular graph. The initial
message sent from the leaf node is simply
µx1 →f1,2 (x1 ) = 0.

(8.99)

The most probable value for xN is then given by
xmax
= arg max µfN −1,N →xN (xN ) .
N

(8.100)

xN

Now we need to determine the states of the previous variables that correspond to the
same maximizing configuration. This can be done by keeping track of which values
of the variables gave rise to the maximum state of each variable, in other words by
storing quantities given by
φ(xn ) = arg max ln fn−1,n (xn−1 , xn ) + µxn−1 →f n−1,n (xn ) .

(8.101)

xn−1

To understand better what is happening, it is helpful to represent the chain of variables in terms of a lattice or trellis diagram as shown in Figure 8.53.
Note that
this is not a probabilistic graphical model because the nodes represent individual
states of variables, while each variable corresponds to a column of such states in the
diagram. For each state of a given variable, there is a unique state of the previous
variable that maximizes the probability (ties are broken either systematically or at
random), corresponding to the function φ(xn ) given by (8.101), and this is indicated

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.4. Inference in Graphical Models

415

by the lines connecting the nodes. Once we know the most probable value of the final node xN , we can then simply follow the link back to find the most probable state
of node xN −1 and so on back to the initial node x1 . This corresponds to propagating
a message back down the chain using
max
xmax
n−1 = φ(xn )

Section 13.2

(8.102)

and is known as back-tracking. Note that there could be several values of xn−1 all
of which give the maximum value in (8.101). Provided we chose one of these values
when we do the back-tracking, we are assured of a globally consistent maximizing
configuration.
In Figure 8.53, we have indicated two paths, each of which we shall suppose
corresponds to a global maximum of the joint probability distribution. If k = 2
and k = 3 each represent possible values of xmax
N , then starting from either state
and tracing back along the black lines, which corresponds to iterating (8.102), we
obtain a valid global maximum configuration. Note that if we had run a forward
pass of max-sum message passing followed by a backward pass and then applied
(8.98) at each node separately, we could end up selecting some states from one path
and some from the other path, giving an overall configuration that is not a global
maximizer. We see that it is necessary instead to keep track of the maximizing states
during the forward pass using the functions φ(xn ) and then use back-tracking to find
a consistent solution.
The extension to a general tree-structured factor graph should now be clear. If
a message is sent from a factor node f to a variable node x, a maximization is
performed over all other variable nodes x1 , . . . , xM that are neighbours of that factor node, using (8.93). When we perform this maximization, we keep a record of
which values of the variables x1 , . . . , xM gave rise to the maximum. Then in the
back-tracking step, having found xmax , we can then use these stored values to assign consistent maximizing states xmax
, . . . , xmax
1
M . The max-sum algorithm, with
back-tracking, gives an exact maximizing configuration for the variables provided
the factor graph is a tree. An important application of this technique is for finding
the most probable sequence of hidden states in a hidden Markov model, in which
case it is known as the Viterbi algorithm.
As with the sum-product algorithm, the inclusion of evidence in the form of
observed variables is straightforward. The observed variables are clamped to their
observed values, and the maximization is performed over the remaining hidden variables. This can be shown formally by including identity functions for the observed
variables into the factor functions, as we did for the sum-product algorithm.
It is interesting to compare max-sum with the iterated conditional modes (ICM)
algorithm described on page 389. Each step in ICM is computationally simpler because the ‘messages’ that are passed from one node to the next comprise a single
value consisting of the new state of the node for which the conditional distribution
is maximized. The max-sum algorithm is more complex because the messages are
functions of node variables x and hence comprise a set of K values for each possible state of x. Unlike max-sum, however, ICM is not guaranteed to find a global
maximum even for tree-structured graphs.

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

416

8. GRAPHICAL MODELS

8.4.6 Exact inference in general graphs
The sum-product and max-sum algorithms provide efficient and exact solutions
to inference problems in tree-structured graphs. For many practical applications,
however, we have to deal with graphs having loops.
The message passing framework can be generalized to arbitrary graph topologies, giving an exact inference procedure known as the junction tree algorithm (Lauritzen and Spiegelhalter, 1988; Jordan, 2007). Here we give a brief outline of the
key steps involved. This is not intended to convey a detailed understanding of the
algorithm, but rather to give a flavour of the various stages involved. If the starting
point is a directed graph, it is first converted to an undirected graph by moralization, whereas if starting from an undirected graph this step is not required. Next the
graph is triangulated, which involves finding chord-less cycles containing four or
more nodes and adding extra links to eliminate such chord-less cycles. For instance,
in the graph in Figure 8.36, the cycle A–C–B–D–A is chord-less a link could be
added between A and B or alternatively between C and D. Note that the joint distribution for the resulting triangulated graph is still defined by a product of the same
potential functions, but these are now considered to be functions over expanded sets
of variables. Next the triangulated graph is used to construct a new tree-structured
undirected graph called a join tree, whose nodes correspond to the maximal cliques
of the triangulated graph, and whose links connect pairs of cliques that have variables in common. The selection of which pairs of cliques to connect in this way is
important and is done so as to give a maximal spanning tree defined as follows. Of
all possible trees that link up the cliques, the one that is chosen is one for which the
weight of the tree is largest, where the weight for a link is the number of nodes shared
by the two cliques it connects, and the weight for the tree is the sum of the weights
for the links. If the tree is condensed, so that any clique that is a subset of another
clique is absorbed into the larger clique, this gives a junction tree. As a consequence
of the triangulation step, the resulting tree satisfies the running intersection property,
which means that if a variable is contained in two cliques, then it must also be contained in every clique on the path that connects them. This ensures that inference
about variables will be consistent across the graph. Finally, a two-stage message
passing algorithm, essentially equivalent to the sum-product algorithm, can now be
applied to this junction tree in order to find marginals and conditionals. Although
the junction tree algorithm sounds complicated, at its heart is the simple idea that
we have used already of exploiting the factorization properties of the distribution to
allow sums and products to be interchanged so that partial summations can be performed, thereby avoiding having to work directly with the joint distribution. The
role of the junction tree is to provide a precise and efficient way to organize these
computations. It is worth emphasizing that this is achieved using purely graphical
operations!
The junction tree is exact for arbitrary graphs and is efficient in the sense that
for a given graph there does not in general exist a computationally cheaper approach.
Unfortunately, the algorithm must work with the joint distributions within each node
(each of which corresponds to a clique of the triangulated graph) and so the computational cost of the algorithm is determined by the number of variables in the largest

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

8.4. Inference in Graphical Models

417

clique and will grow exponentially with this number in the case of discrete variables.
An important concept is the treewidth of a graph (Bodlaender, 1993), which is defined in terms of the number of variables in the largest clique. In fact, it is defined to
be as one less than the size of the largest clique, to ensure that a tree has a treewidth
of 1. Because there in general there can be multiple different junction trees that can
be constructed from a given starting graph, the treewidth is defined by the junction
tree for which the largest clique has the fewest variables. If the treewidth of the
original graph is high, the junction tree algorithm becomes impractical.

8.4.7 Loopy belief propagation
For many problems of practical interest, it will not be feasible to use exact inference, and so we need to exploit effective approximation methods. An important
class of such approximations, that can broadly be called variational methods, will be
discussed in detail in Chapter 10. Complementing these deterministic approaches is
a wide range of sampling methods, also called Monte Carlo methods, that are based
on stochastic numerical sampling from distributions and that will be discussed at
length in Chapter 11.
Here we consider one simple approach to approximate inference in graphs with
loops, which builds directly on the previous discussion of exact inference in trees.
The idea is simply to apply the sum-product algorithm even though there is no guarantee that it will yield good results. This approach is known as loopy belief propagation (Frey and MacKay, 1998) and is possible because the message passing rules
(8.66) and (8.69) for the sum-product algorithm are purely local. However, because
the graph now has cycles, information can flow many times around the graph. For
some models, the algorithm will converge, whereas for others it will not.
In order to apply this approach, we need to define a message passing schedule.
Let us assume that one message is passed at a time on any given link and in any
given direction. Each message sent from a node replaces any previous message sent
in the same direction across the same link and will itself be a function only of the
most recent messages received by that node at previous steps of the algorithm.
We have seen that a message can only be sent across a link from a node when
all other messages have been received by that node across its other links. Because
there are loops in the graph, this raises the problem of how to initiate the message
passing algorithm. To resolve this, we suppose that an initial message given by the
unit function has been passed across every link in each direction. Every node is then
in a position to send a message.
There are now many possible ways to organize the message passing schedule.
For example, the flooding schedule simultaneously passes a message across every
link in both directions at each time step, whereas schedules that pass one message at
a time are called serial schedules.
Following Kschischnang et al. (2001), we will say that a (variable or factor)
node a has a message pending on its link to a node b if node a has received any
message on any of its other links since the last time it send a message to b. Thus,
when a node receives a message on one of its links, this creates pending messages
on all of its other links. Only pending messages need to be transmitted because

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

418

8. GRAPHICAL MODELS

Exercise 8.29

other messages would simply duplicate the previous message on the same link. For
graphs that have a tree structure, any schedule that sends only pending messages
will eventually terminate once a message has passed in each direction across every
link. At this point, there are no pending messages, and the product of the received
messages at every variable give the exact marginal. In graphs having loops, however,
the algorithm may never terminate because there might always be pending messages,
although in practice it is generally found to converge within a reasonable time for
most applications. Once the algorithm has converged, or once it has been stopped
if convergence is not observed, the (approximate) local marginals can be computed
using the product of the most recently received incoming messages to each variable
node or factor node on every link.
In some applications, the loopy belief propagation algorithm can give poor results, whereas in other applications it has proven to be very effective. In particular,
state-of-the-art algorithms for decoding certain kinds of error-correcting codes are
equivalent to loopy belief propagation (Gallager, 1963; Berrou et al., 1993; McEliece
et al., 1998; MacKay and Neal, 1999; Frey, 1998).

8.4.8 Learning the graph structure
In our discussion of inference in graphical models, we have assumed that the
structure of the graph is known and fixed. However, there is also interest in going beyond the inference problem and learning the graph structure itself from data
(Friedman and Koller, 2003). This requires that we define a space of possible structures as well as a measure that can be used to score each structure.
From a Bayesian viewpoint, we would ideally like to compute a posterior distribution over graph structures and to make predictions by averaging with respect
to this distribution. If we have a prior p(m) over graphs indexed by m, then the
posterior distribution is given by
p(m|D) ∝ p(m)p(D|m)

(8.103)

where D is the observed data set. The model evidence p(D|m) then provides the
score for each model. However, evaluation of the evidence involves marginalization
over the latent variables and presents a challenging computational problem for many
models.
Exploring the space of structures can also be problematic. Because the number
of different graph structures grows exponentially with the number of nodes, it is
often necessary to resort to heuristics to find good candidates.

Exercises

8.1 ( ) www By marginalizing out the variables in order, show that the representation
(8.5) for the joint distribution of a directed graph is correctly normalized, provided
each of the conditional distributions is normalized.
8.2 ( ) www Show that the property of there being no directed cycles in a directed
graph follows from the statement that there exists an ordered numbering of the nodes
such that for each node there are no links going to a lower-numbered node.

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

Exercises
Table 8.2 The joint distribution over three binary variables.

a
0
0
0
0
1
1
1
1

b
0
0
1
1
0
0
1
1

c
0
1
0
1
0
1
0
1

419

p(a, b, c) × 1000
192
144
48
216
192
64
48
96

8.3 ( ) Consider three binary variables a, b, c ∈ {0, 1} having the joint distribution
given in Table 8.2. Show by direct evaluation that this distribution has the property
that a and b are marginally dependent, so that p(a, b) = p(a)p(b), but that they
become independent when conditioned on c, so that p(a, b|c) = p(a|c)p(b|c) for
both c = 0 and c = 1.
8.4 ( ) Evaluate the distributions p(a), p(b|c), and p(c|a) corresponding to the joint
distribution given in Table 8.2. Hence show by direct evaluation that p(a, b, c) =
p(a)p(c|a)p(b|c). Draw the corresponding directed graph.
8.5 ( ) www Draw a directed probabilistic graphical model corresponding to the
relevance vector machine described by (7.79) and (7.80).
8.6 ( ) For the model shown in Figure 8.13, we have seen that the number of parameters
required to specify the conditional distribution p(y|x1 , . . . , xM ), where xi ∈ {0, 1},
could be reduced from 2M to M + 1 by making use of the logistic sigmoid representation (8.10). An alternative representation (Pearl, 1988) is given by
M

p(y = 1|x1 , . . . , xM ) = 1 − (1 − µ0 )

i=1

(1 − µi )xi

(8.104)

where the parameters µi represent the probabilities p(xi = 1), and µ0 is an additional
parameters satisfying 0 µ0 1. The conditional distribution (8.104) is known as
the noisy-OR. Show that this can be interpreted as a ‘soft’ (probabilistic) form of the
logical OR function (i.e., the function that gives y = 1 whenever at least one of the
xi = 1). Discuss the interpretation of µ0 .
8.7 ( ) Using the recursion relations (8.15) and (8.16), show that the mean and covariance of the joint distribution for the graph shown in Figure 8.14 are given by (8.17)
and (8.18), respectively.
8.8 ( ) www

Show that a ⊥
⊥ b, c | d implies a ⊥
⊥ b | d.

8.9 ( ) www Using the d-separation criterion, show that the conditional distribution
for a node x in a directed graph, conditioned on all of the nodes in the Markov
blanket, is independent of the remaining variables in the graph.

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

420

8. GRAPHICAL MODELS
Figure 8.54 Example of a graphical model used to explore the con- a
ditional independence properties of the head-to-head
path a–c–b when a descendant of c, namely the node
d, is observed.

b

c

d

8.10 ( ) Consider the directed graph shown in Figure 8.54 in which none of the variables
is observed. Show that a ⊥
⊥ b | ∅. Suppose we now observe the variable d. Show
that in general a ⊥
⊥ b | d.
8.11 ( ) Consider the example of the car fuel system shown in Figure 8.21, and suppose
that instead of observing the state of the fuel gauge G directly, the gauge is seen by
the driver D who reports to us the reading on the gauge. This report is either that the
gauge shows full D = 1 or that it shows empty D = 0. Our driver is a bit unreliable,
as expressed through the following probabilities
p(D = 1|G = 1) = 0.9
p(D = 0|G = 0) = 0.9.

(8.105)
(8.106)

Suppose that the driver tells us that the fuel gauge shows empty, in other words
that we observe D = 0. Evaluate the probability that the tank is empty given only
this observation. Similarly, evaluate the corresponding probability given also the
observation that the battery is flat, and note that this second probability is lower.
Discuss the intuition behind this result, and relate the result to Figure 8.54.
8.12 ( ) www Show that there are 2M (M −1)/2 distinct undirected graphs over a set of
M distinct random variables. Draw the 8 possibilities for the case of M = 3.
8.13 ( ) Consider the use of iterated conditional modes (ICM) to minimize the energy
function given by (8.42). Write down an expression for the difference in the values
of the energy associated with the two states of a particular variable xj , with all other
variables held fixed, and show that it depends only on quantities that are local to xj
in the graph.
8.14 ( ) Consider a particular case of the energy function given by (8.42) in which the
coefficients β = h = 0. Show that the most probable configuration of the latent
variables is given by xi = yi for all i.
8.15 ( ) www Show that the joint distribution p(xn−1 , xn ) for two neighbouring
nodes in the graph shown in Figure 8.38 is given by an expression of the form (8.58).

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

Exercises

421

8.16 ( ) Consider the inference problem of evaluating p(xn |xN ) for the graph shown
in Figure 8.38, for all nodes n ∈ {1, . . . , N − 1}. Show that the message passing
algorithm discussed in Section 8.4.1 can be used to solve this efficiently, and discuss
which messages are modified and in what way.
8.17 ( ) Consider a graph of the form shown in Figure 8.38 having N = 5 nodes, in
which nodes x3 and x5 are observed. Use d-separation to show that x2 ⊥
⊥ x5 | x3 .
Show that if the message passing algorithm of Section 8.4.1 is applied to the evaluation of p(x2 |x3 , x5 ), the result will be independent of the value of x5 .
8.18 ( ) www Show that a distribution represented by a directed tree can trivially
be written as an equivalent distribution over the corresponding undirected tree. Also
show that a distribution expressed as an undirected tree can, by suitable normalization of the clique potentials, be written as a directed tree. Calculate the number of
distinct directed trees that can be constructed from a given undirected tree.
8.19 ( ) Apply the sum-product algorithm derived in Section 8.4.4 to the chain-ofnodes model discussed in Section 8.4.1 and show that the results (8.54), (8.55), and
(8.57) are recovered as a special case.
8.20 ( ) www Consider the message passing protocol for the sum-product algorithm on
a tree-structured factor graph in which messages are first propagated from the leaves
to an arbitrarily chosen root node and then from the root node out to the leaves. Use
proof by induction to show that the messages can be passed in such an order that
at every step, each node that must send a message has received all of the incoming
messages necessary to construct its outgoing messages.
8.21 ( ) www Show that the marginal distributions p(xs ) over the sets of variables
xs associated with each of the factors fx (xs ) in a factor graph can be found by first
running the sum-product message passing algorithm and then evaluating the required
marginals using (8.72).
8.22 ( ) Consider a tree-structured factor graph, in which a given subset of the variable
nodes form a connected subgraph (i.e., any variable node of the subset is connected
to at least one of the other variable nodes via a single factor node). Show how the
sum-product algorithm can be used to compute the marginal distribution over that
subset.
8.23 ( ) www In Section 8.4.4, we showed that the marginal distribution p(xi ) for a
variable node xi in a factor graph is given by the product of the messages arriving at
this node from neighbouring factor nodes in the form (8.63). Show that the marginal
p(xi ) can also be written as the product of the incoming message along any one of
the links with the outgoing message along the same link.
8.24 ( ) Show that the marginal distribution for the variables xs in a factor fs (xs ) in
a tree-structured factor graph, after running the sum-product message passing algorithm, can be written as the product of the message arriving at the factor node along
all its links, times the local factor f (xs ), in the form (8.72).

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

422

8. GRAPHICAL MODELS
8.25 ( ) In (8.86), we verified that the sum-product algorithm run on the graph in
Figure 8.51 with node x3 designated as the root node gives the correct marginal for
x2 . Show that the correct marginals are obtained also for x1 and x3 . Similarly, show
that the use of the result (8.72) after running the sum-product algorithm on this graph
gives the correct joint distribution for x1 , x2 .
8.26 ( ) Consider a tree-structured factor graph over discrete variables, and suppose we
wish to evaluate the joint distribution p(xa , xb ) associated with two variables xa and
xb that do not belong to a common factor. Define a procedure for using the sumproduct algorithm to evaluate this joint distribution in which one of the variables is
successively clamped to each of its allowed values.
8.27 ( ) Consider two discrete variables x and y each having three possible states, for
example x, y ∈ {0, 1, 2}. Construct a joint distribution p(x, y) over these variables
having the property that the value x that maximizes the marginal p(x), along with
the value y that maximizes the marginal p(y), together have probability zero under
the joint distribution, so that p(x, y) = 0.
8.28 ( ) www The concept of a pending message in the sum-product algorithm for
a factor graph was defined in Section 8.4.7. Show that if the graph has one or more
cycles, there will always be at least one pending message irrespective of how long
the algorithm runs.
8.29 ( ) www Show that if the sum-product algorithm is run on a factor graph with a
tree structure (no loops), then after a finite number of messages have been sent, there
will be no pending messages.

c Christopher M. Bishop (2002–2006). Springer, 2006. First printing.
Further information available at http://research.microsoft.com/∼cmbishop/PRML

